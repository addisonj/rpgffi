/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type size_t = usize;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for __fsid_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: Union_Unnamed1,
}
impl ::std::default::Default for __mbstate_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed1 {
    pub unsafe fn __wch(&mut self) -> *mut ::std::os::raw::c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl ::std::default::Default for _G_fpos_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl ::std::default::Default for _G_fpos64_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum _IO_jump_t { }
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
impl ::std::default::Default for _IO_marker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl ::std::default::Default for _IO_FILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum _IO_FILE_plus { }
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: size_t)
                              -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: size_t) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type off_t = __off_t;
pub type ssize_t = isize;
pub type fpos_t = _G_fpos_t;
pub type wchar_t = ::std::os::raw::c_int;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl wait {
    pub unsafe fn w_status(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_terminated(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_stopped(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed2 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __WAIT_STATUS {
    pub _bindgen_data_: [u64; 1usize],
}
impl __WAIT_STATUS {
    pub unsafe fn __uptr(&mut self) -> *mut *mut wait {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __iptr(&mut self) -> *mut *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for __WAIT_STATUS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
impl ::std::default::Default for div_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::default::Default for ldiv_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
impl ::std::default::Default for lldiv_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint_ = ::std::os::raw::c_uint;
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for __sigset_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::default::Default for fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_attr_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl ::std::default::Default for __pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_mutex_t {
    pub _bindgen_data_: [u64; 5usize],
}
impl pthread_mutex_t {
    pub unsafe fn __data(&mut self) -> *mut __pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for __pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_mutexattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t {
    pub _bindgen_data_: [u64; 6usize],
}
impl pthread_cond_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed4 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_condattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_condattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_rwlock_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_rwlock_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed5 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed5 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_rwlockattr_t {
    pub _bindgen_data_: [u64; 1usize],
}
impl pthread_rwlockattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub _bindgen_data_: [u64; 4usize],
}
impl pthread_barrier_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrier_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrierattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_barrierattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrierattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut int32_t,
}
impl ::std::default::Default for random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
impl ::std::default::Default for drand48_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub enum __locale_data { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
impl ::std::default::Default for __locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub type ptrdiff_t = isize;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __max_align_ld: f64,
}
impl ::std::default::Default for max_align_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
impl ::std::default::Default for lconv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bool_ = ::std::os::raw::c_char;
pub type BoolPtr = *mut bool_;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_char;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type Size = size_t;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IntArray {
    pub indx: [::std::os::raw::c_int; 6usize],
}
impl ::std::default::Default for IntArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for varlena {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: [int16; 1usize],
}
impl ::std::default::Default for int2vector {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: [Oid; 1usize],
}
impl ::std::default::Default for oidvector {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
impl ::std::clone::Clone for nameData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for nameData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NameData = nameData;
pub type Name = *mut NameData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed6 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
impl ::std::default::Default for iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type socklen_t = __socklen_t;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
impl ::std::default::Default for sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed7 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl ::std::default::Default for msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: [::std::os::raw::c_uchar; 0usize],
}
impl ::std::default::Default for cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed8 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
impl ::std::default::Default for linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
impl ::std::default::Default for osockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed9 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
pub type in_addr_t = uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
impl ::std::default::Default for in_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
impl ::std::clone::Clone for ip_opts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for ip_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for ip_mreqn {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
impl ::std::default::Default for in_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed10 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed11 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = uint16_t;
pub const IPPORT_BIFFUDP: Enum_Unnamed12 = Enum_Unnamed12::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: Enum_Unnamed12 =
    Enum_Unnamed12::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: Enum_Unnamed12 =
    Enum_Unnamed12::IPPORT_EFSSERVER;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed12 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: Union_Unnamed13,
}
impl ::std::default::Default for in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed13 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed13 {
    pub unsafe fn __u6_addr8(&mut self) -> *mut [uint8_t; 16usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr16(&mut self) -> *mut [uint16_t; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr32(&mut self) -> *mut [uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
impl ::std::default::Default for sockaddr_in {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
impl ::std::default::Default for sockaddr_in6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
impl ::std::default::Default for ip_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
impl ::std::default::Default for ip_mreq_source {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
impl ::std::default::Default for ipv6_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_req {
    pub gr_interface: uint32_t,
    pub gr_group: sockaddr_storage,
}
impl ::std::clone::Clone for group_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for group_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
impl ::std::clone::Clone for group_source_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for group_source_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: uint32_t,
    pub imsf_numsrc: uint32_t,
    pub imsf_slist: [in_addr; 1usize],
}
impl ::std::default::Default for ip_msfilter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_filter {
    pub gf_interface: uint32_t,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: uint32_t,
    pub gf_numsrc: uint32_t,
    pub gf_slist: [sockaddr_storage; 1usize],
}
impl ::std::clone::Clone for group_filter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for group_filter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
impl ::std::default::Default for rpcent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: uint32_t,
}
impl ::std::default::Default for netent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for hostent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for servent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
impl ::std::default::Default for protoent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
impl ::std::default::Default for addrinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for passwd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgsocket = ::std::os::raw::c_int;
pub type qsort_arg_comparator =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *const ::std::os::raw::c_void,
                                               b:
                                                   *const ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type pqsigfunc =
    ::std::option::Option<extern "C" fn(signo: ::std::os::raw::c_int)>;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
impl ::std::default::Default for __jmp_buf_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for ErrorContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool_,
    pub output_to_client: bool_,
    pub show_funcname: bool_,
    pub hide_stmt: bool_,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
}
impl ::std::default::Default for ErrorData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type emit_log_hook_type =
    ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum PGErrorVerbosity {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
pub enum MemoryContextData { }
pub type MemoryContext = *mut MemoryContextData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl ::std::default::Default for varatt_external {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct varattrib_4b {
    pub _bindgen_data_: [u32; 3usize],
}
impl varattrib_4b {
    pub unsafe fn va_4byte(&mut self) -> *mut Struct_Unnamed14 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn va_compressed(&mut self) -> *mut Struct_Unnamed15 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for varattrib_4b {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed14 {
    pub va_header: uint32,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed15 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for varattrib_1b {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_len_1be: uint8,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for varattrib_1b_e {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Datum = uintptr_t;
pub type DatumPtr = *mut Datum;
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
impl ::std::default::Default for BlockIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ItemIdData {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for ItemIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl ::std::default::Default for ItemPointerData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemPointer = *mut ItemPointerData;
pub enum HeapTupleHeaderData { }
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub enum MinimalTupleData { }
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl ::std::default::Default for HeapTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTuple = *mut HeapTupleData;
pub type AttrNumber = int16;
pub type aclitem = ::std::os::raw::c_int;
pub type pg_node_tree = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool_,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool_,
    pub atthasdef: bool_,
    pub attisdropped: bool_,
    pub attislocal: bool_,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl ::std::default::Default for FormData_pg_attribute {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 10,
    T_ExprContext = 11,
    T_ProjectionInfo = 12,
    T_JunkFilter = 13,
    T_ResultRelInfo = 14,
    T_EState = 15,
    T_TupleTableSlot = 16,
    T_Plan = 100,
    T_Result = 101,
    T_ModifyTable = 102,
    T_Append = 103,
    T_MergeAppend = 104,
    T_RecursiveUnion = 105,
    T_BitmapAnd = 106,
    T_BitmapOr = 107,
    T_Scan = 108,
    T_SeqScan = 109,
    T_IndexScan = 110,
    T_IndexOnlyScan = 111,
    T_BitmapIndexScan = 112,
    T_BitmapHeapScan = 113,
    T_TidScan = 114,
    T_SubqueryScan = 115,
    T_FunctionScan = 116,
    T_ValuesScan = 117,
    T_CteScan = 118,
    T_WorkTableScan = 119,
    T_ForeignScan = 120,
    T_Join = 121,
    T_NestLoop = 122,
    T_MergeJoin = 123,
    T_HashJoin = 124,
    T_Material = 125,
    T_Sort = 126,
    T_Group = 127,
    T_Agg = 128,
    T_WindowAgg = 129,
    T_Unique = 130,
    T_Hash = 131,
    T_SetOp = 132,
    T_LockRows = 133,
    T_Limit = 134,
    T_NestLoopParam = 135,
    T_PlanRowMark = 136,
    T_PlanInvalItem = 137,
    T_PlanState = 200,
    T_ResultState = 201,
    T_ModifyTableState = 202,
    T_AppendState = 203,
    T_MergeAppendState = 204,
    T_RecursiveUnionState = 205,
    T_BitmapAndState = 206,
    T_BitmapOrState = 207,
    T_ScanState = 208,
    T_SeqScanState = 209,
    T_IndexScanState = 210,
    T_IndexOnlyScanState = 211,
    T_BitmapIndexScanState = 212,
    T_BitmapHeapScanState = 213,
    T_TidScanState = 214,
    T_SubqueryScanState = 215,
    T_FunctionScanState = 216,
    T_ValuesScanState = 217,
    T_CteScanState = 218,
    T_WorkTableScanState = 219,
    T_ForeignScanState = 220,
    T_JoinState = 221,
    T_NestLoopState = 222,
    T_MergeJoinState = 223,
    T_HashJoinState = 224,
    T_MaterialState = 225,
    T_SortState = 226,
    T_GroupState = 227,
    T_AggState = 228,
    T_WindowAggState = 229,
    T_UniqueState = 230,
    T_HashState = 231,
    T_SetOpState = 232,
    T_LockRowsState = 233,
    T_LimitState = 234,
    T_Alias = 300,
    T_RangeVar = 301,
    T_Expr = 302,
    T_Var = 303,
    T_Const = 304,
    T_Param = 305,
    T_Aggref = 306,
    T_WindowFunc = 307,
    T_ArrayRef = 308,
    T_FuncExpr = 309,
    T_NamedArgExpr = 310,
    T_OpExpr = 311,
    T_DistinctExpr = 312,
    T_NullIfExpr = 313,
    T_ScalarArrayOpExpr = 314,
    T_BoolExpr = 315,
    T_SubLink = 316,
    T_SubPlan = 317,
    T_AlternativeSubPlan = 318,
    T_FieldSelect = 319,
    T_FieldStore = 320,
    T_RelabelType = 321,
    T_CoerceViaIO = 322,
    T_ArrayCoerceExpr = 323,
    T_ConvertRowtypeExpr = 324,
    T_CollateExpr = 325,
    T_CaseExpr = 326,
    T_CaseWhen = 327,
    T_CaseTestExpr = 328,
    T_ArrayExpr = 329,
    T_RowExpr = 330,
    T_RowCompareExpr = 331,
    T_CoalesceExpr = 332,
    T_MinMaxExpr = 333,
    T_XmlExpr = 334,
    T_NullTest = 335,
    T_BooleanTest = 336,
    T_CoerceToDomain = 337,
    T_CoerceToDomainValue = 338,
    T_SetToDefault = 339,
    T_CurrentOfExpr = 340,
    T_TargetEntry = 341,
    T_RangeTblRef = 342,
    T_JoinExpr = 343,
    T_FromExpr = 344,
    T_IntoClause = 345,
    T_ExprState = 400,
    T_GenericExprState = 401,
    T_WholeRowVarExprState = 402,
    T_AggrefExprState = 403,
    T_WindowFuncExprState = 404,
    T_ArrayRefExprState = 405,
    T_FuncExprState = 406,
    T_ScalarArrayOpExprState = 407,
    T_BoolExprState = 408,
    T_SubPlanState = 409,
    T_AlternativeSubPlanState = 410,
    T_FieldSelectState = 411,
    T_FieldStoreState = 412,
    T_CoerceViaIOState = 413,
    T_ArrayCoerceExprState = 414,
    T_ConvertRowtypeExprState = 415,
    T_CaseExprState = 416,
    T_CaseWhenState = 417,
    T_ArrayExprState = 418,
    T_RowExprState = 419,
    T_RowCompareExprState = 420,
    T_CoalesceExprState = 421,
    T_MinMaxExprState = 422,
    T_XmlExprState = 423,
    T_NullTestState = 424,
    T_CoerceToDomainState = 425,
    T_DomainConstraintState = 426,
    T_PlannerInfo = 500,
    T_PlannerGlobal = 501,
    T_RelOptInfo = 502,
    T_IndexOptInfo = 503,
    T_ParamPathInfo = 504,
    T_Path = 505,
    T_IndexPath = 506,
    T_BitmapHeapPath = 507,
    T_BitmapAndPath = 508,
    T_BitmapOrPath = 509,
    T_NestPath = 510,
    T_MergePath = 511,
    T_HashPath = 512,
    T_TidPath = 513,
    T_ForeignPath = 514,
    T_AppendPath = 515,
    T_MergeAppendPath = 516,
    T_ResultPath = 517,
    T_MaterialPath = 518,
    T_UniquePath = 519,
    T_EquivalenceClass = 520,
    T_EquivalenceMember = 521,
    T_PathKey = 522,
    T_RestrictInfo = 523,
    T_PlaceHolderVar = 524,
    T_SpecialJoinInfo = 525,
    T_LateralJoinInfo = 526,
    T_AppendRelInfo = 527,
    T_PlaceHolderInfo = 528,
    T_MinMaxAggInfo = 529,
    T_PlannerParamItem = 530,
    T_MemoryContext = 600,
    T_AllocSetContext = 601,
    T_Value = 650,
    T_Integer = 651,
    T_Float = 652,
    T_String = 653,
    T_BitString = 654,
    T_Null = 655,
    T_List = 656,
    T_IntList = 657,
    T_OidList = 658,
    T_Query = 700,
    T_PlannedStmt = 701,
    T_InsertStmt = 702,
    T_DeleteStmt = 703,
    T_UpdateStmt = 704,
    T_SelectStmt = 705,
    T_AlterTableStmt = 706,
    T_AlterTableCmd = 707,
    T_AlterDomainStmt = 708,
    T_SetOperationStmt = 709,
    T_GrantStmt = 710,
    T_GrantRoleStmt = 711,
    T_AlterDefaultPrivilegesStmt = 712,
    T_ClosePortalStmt = 713,
    T_ClusterStmt = 714,
    T_CopyStmt = 715,
    T_CreateStmt = 716,
    T_DefineStmt = 717,
    T_DropStmt = 718,
    T_TruncateStmt = 719,
    T_CommentStmt = 720,
    T_FetchStmt = 721,
    T_IndexStmt = 722,
    T_CreateFunctionStmt = 723,
    T_AlterFunctionStmt = 724,
    T_DoStmt = 725,
    T_RenameStmt = 726,
    T_RuleStmt = 727,
    T_NotifyStmt = 728,
    T_ListenStmt = 729,
    T_UnlistenStmt = 730,
    T_TransactionStmt = 731,
    T_ViewStmt = 732,
    T_LoadStmt = 733,
    T_CreateDomainStmt = 734,
    T_CreatedbStmt = 735,
    T_DropdbStmt = 736,
    T_VacuumStmt = 737,
    T_ExplainStmt = 738,
    T_CreateTableAsStmt = 739,
    T_CreateSeqStmt = 740,
    T_AlterSeqStmt = 741,
    T_VariableSetStmt = 742,
    T_VariableShowStmt = 743,
    T_DiscardStmt = 744,
    T_CreateTrigStmt = 745,
    T_CreatePLangStmt = 746,
    T_CreateRoleStmt = 747,
    T_AlterRoleStmt = 748,
    T_DropRoleStmt = 749,
    T_LockStmt = 750,
    T_ConstraintsSetStmt = 751,
    T_ReindexStmt = 752,
    T_CheckPointStmt = 753,
    T_CreateSchemaStmt = 754,
    T_AlterDatabaseStmt = 755,
    T_AlterDatabaseSetStmt = 756,
    T_AlterRoleSetStmt = 757,
    T_CreateConversionStmt = 758,
    T_CreateCastStmt = 759,
    T_CreateOpClassStmt = 760,
    T_CreateOpFamilyStmt = 761,
    T_AlterOpFamilyStmt = 762,
    T_PrepareStmt = 763,
    T_ExecuteStmt = 764,
    T_DeallocateStmt = 765,
    T_DeclareCursorStmt = 766,
    T_CreateTableSpaceStmt = 767,
    T_DropTableSpaceStmt = 768,
    T_AlterObjectSchemaStmt = 769,
    T_AlterOwnerStmt = 770,
    T_DropOwnedStmt = 771,
    T_ReassignOwnedStmt = 772,
    T_CompositeTypeStmt = 773,
    T_CreateEnumStmt = 774,
    T_CreateRangeStmt = 775,
    T_AlterEnumStmt = 776,
    T_AlterTSDictionaryStmt = 777,
    T_AlterTSConfigurationStmt = 778,
    T_CreateFdwStmt = 779,
    T_AlterFdwStmt = 780,
    T_CreateForeignServerStmt = 781,
    T_AlterForeignServerStmt = 782,
    T_CreateUserMappingStmt = 783,
    T_AlterUserMappingStmt = 784,
    T_DropUserMappingStmt = 785,
    T_AlterTableSpaceOptionsStmt = 786,
    T_SecLabelStmt = 787,
    T_CreateForeignTableStmt = 788,
    T_CreateExtensionStmt = 789,
    T_AlterExtensionStmt = 790,
    T_AlterExtensionContentsStmt = 791,
    T_CreateEventTrigStmt = 792,
    T_AlterEventTrigStmt = 793,
    T_RefreshMatViewStmt = 794,
    T_A_Expr = 900,
    T_ColumnRef = 901,
    T_ParamRef = 902,
    T_A_Const = 903,
    T_FuncCall = 904,
    T_A_Star = 905,
    T_A_Indices = 906,
    T_A_Indirection = 907,
    T_A_ArrayExpr = 908,
    T_ResTarget = 909,
    T_TypeCast = 910,
    T_CollateClause = 911,
    T_SortBy = 912,
    T_WindowDef = 913,
    T_RangeSubselect = 914,
    T_RangeFunction = 915,
    T_TypeName = 916,
    T_ColumnDef = 917,
    T_IndexElem = 918,
    T_Constraint = 919,
    T_DefElem = 920,
    T_RangeTblEntry = 921,
    T_SortGroupClause = 922,
    T_WindowClause = 923,
    T_PrivGrantee = 924,
    T_FuncWithArgs = 925,
    T_AccessPriv = 926,
    T_CreateOpClassItem = 927,
    T_TableLikeClause = 928,
    T_FunctionParameter = 929,
    T_LockingClause = 930,
    T_RowMarkClause = 931,
    T_XmlSerialize = 932,
    T_WithClause = 933,
    T_CommonTableExpr = 934,
    T_IdentifySystemCmd = 935,
    T_BaseBackupCmd = 936,
    T_StartReplicationCmd = 937,
    T_TimeLineHistoryCmd = 938,
    T_TriggerData = 950,
    T_EventTriggerData = 951,
    T_ReturnSetInfo = 952,
    T_WindowObjectData = 953,
    T_TIDBitmap = 954,
    T_InlineCodeBlock = 955,
    T_FdwRoutine = 956,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Node {
    pub type_: NodeTag,
}
impl ::std::default::Default for Node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Selectivity = f64;
pub type Cost = f64;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
impl ::std::default::Default for List {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ListCell {
    pub data: Union_Unnamed16,
    pub next: *mut ListCell,
}
impl ::std::default::Default for ListCell {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed16 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed16 {
    pub unsafe fn ptr_value(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_value(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn oid_value(&mut self) -> *mut Oid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for attrDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AttrDefault = attrDefault;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool_,
    pub ccnoinherit: bool_,
}
impl ::std::default::Default for constrCheck {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstrCheck = constrCheck;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool_,
}
impl ::std::default::Default for tupleConstr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleConstr = tupleConstr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: bool_,
    pub tdrefcount: ::std::os::raw::c_int,
}
impl ::std::default::Default for tupleDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleDesc = *mut tupleDesc;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum relopt_type {
    RELOPT_TYPE_BOOL = 0,
    RELOPT_TYPE_INT = 1,
    RELOPT_TYPE_REAL = 2,
    RELOPT_TYPE_STRING = 3,
}
pub const RELOPT_KIND_LAST_DEFAULT: relopt_kind =
    relopt_kind::RELOPT_KIND_VIEW;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum relopt_kind {
    RELOPT_KIND_HEAP = 1,
    RELOPT_KIND_TOAST = 2,
    RELOPT_KIND_BTREE = 4,
    RELOPT_KIND_HASH = 8,
    RELOPT_KIND_GIN = 16,
    RELOPT_KIND_GIST = 32,
    RELOPT_KIND_ATTRIBUTE = 64,
    RELOPT_KIND_TABLESPACE = 128,
    RELOPT_KIND_SPGIST = 256,
    RELOPT_KIND_VIEW = 512,
    RELOPT_KIND_MAX = 1073741824,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_gen {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub kinds: bits32,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
impl ::std::default::Default for relopt_gen {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool_,
    pub values: Union_Unnamed17,
}
impl ::std::default::Default for relopt_value {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed17 {
    pub unsafe fn bool_val(&mut self) -> *mut bool_ {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_val(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn real_val(&mut self) -> *mut f64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn string_val(&mut self) -> *mut *mut ::std::os::raw::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool_,
}
impl ::std::default::Default for relopt_bool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
impl ::std::default::Default for relopt_int {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
impl ::std::default::Default for relopt_real {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value:
                                                   *mut ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool_,
    pub validate_cb: validate_string_relopt,
    pub default_val: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for relopt_string {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_parse_elt {
    pub optname: *const ::std::os::raw::c_char,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
impl ::std::default::Default for relopt_parse_elt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fmNodePtr = *mut Node;
pub type fmStringInfo = *mut StringInfoData;
pub type FunctionCallInfo = *mut FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool_,
    pub fn_retset: bool_,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl ::std::default::Default for FmgrInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool_,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [bool_; 100usize],
}
impl ::std::clone::Clone for FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for FunctionCallInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
impl ::std::default::Default for Pg_finfo_record {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PGFInfoFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
impl ::std::default::Default for Pg_magic_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PGModuleMagicFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_magic_struct>;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum FmgrHookEventType { FHET_START = 0, FHET_END = 1, FHET_ABORT = 2, }
pub type needs_fmgr_hook_type =
    ::std::option::Option<extern "C" fn(fn_oid: Oid) -> bool_>;
pub type fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(event: FmgrHookEventType,
                                               flinfo: *mut FmgrInfo,
                                               arg: *mut Datum)>;
#[derive(Copy, Clone)]
#[repr(i32)]
pub enum ScanDirection {
    BackwardScanDirection = -1,
    NoMovementScanDirection = 0,
    ForwardScanDirection = 1,
}
pub type StrategyNumber = uint16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
impl ::std::default::Default for ScanKeyData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ScanKey = *mut ScanKeyData;
pub enum TIDBitmap { }
pub enum TBMIterator { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool_,
    pub offsets: [OffsetNumber; 1usize],
}
impl ::std::default::Default for TBMIterateResult {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BackendId = ::std::os::raw::c_int;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LWLockId {
    BufFreelistLock = 0,
    ShmemIndexLock = 1,
    OidGenLock = 2,
    XidGenLock = 3,
    ProcArrayLock = 4,
    SInvalReadLock = 5,
    SInvalWriteLock = 6,
    WALInsertLock = 7,
    WALWriteLock = 8,
    ControlFileLock = 9,
    CheckpointLock = 10,
    CLogControlLock = 11,
    SubtransControlLock = 12,
    MultiXactGenLock = 13,
    MultiXactOffsetControlLock = 14,
    MultiXactMemberControlLock = 15,
    RelCacheInitLock = 16,
    CheckpointerCommLock = 17,
    TwoPhaseStateLock = 18,
    TablespaceCreateLock = 19,
    BtreeVacuumLock = 20,
    AddinShmemInitLock = 21,
    AutovacuumLock = 22,
    AutovacuumScheduleLock = 23,
    SyncScanLock = 24,
    RelationMappingLock = 25,
    AsyncCtlLock = 26,
    AsyncQueueLock = 27,
    SerializableXactHashLock = 28,
    SerializableFinishedListLock = 29,
    SerializablePredicateLockListLock = 30,
    OldSerXidLock = 31,
    SyncRepLock = 32,
    FirstBufMappingLock = 33,
    FirstLockMgrLock = 49,
    FirstPredicateLockMgrLock = 65,
    NumFixedLWLocks = 81,
    MaxDynamicLWLock = 1000000000,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
pub type HashValueFunc =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(dest:
                                                   *mut ::std::os::raw::c_void,
                                               src:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> *mut ::std::os::raw::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<extern "C" fn(request: Size)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
impl ::std::default::Default for HASHELEMENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum HASHHDR { }
pub enum HTAB { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl ::std::default::Default for HASHCTL {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum HASHACTION {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl ::std::default::Default for HASH_SEQ_STATUS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHM_QUEUE {
    pub prev: *mut SHM_QUEUE,
    pub next: *mut SHM_QUEUE,
}
impl ::std::default::Default for SHM_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ShmemIndexEnt {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl ::std::clone::Clone for ShmemIndexEnt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for ShmemIndexEnt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum PGPROC { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::std::os::raw::c_int,
}
impl ::std::default::Default for PROC_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VirtualTransactionId {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
impl ::std::default::Default for VirtualTransactionId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::std::os::raw::c_char,
    pub trace_flag: *const bool_,
}
impl ::std::default::Default for LockMethodData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LockTagType {
    LOCKTAG_RELATION = 0,
    LOCKTAG_RELATION_EXTEND = 1,
    LOCKTAG_PAGE = 2,
    LOCKTAG_TUPLE = 3,
    LOCKTAG_TRANSACTION = 4,
    LOCKTAG_VIRTUALTRANSACTION = 5,
    LOCKTAG_OBJECT = 6,
    LOCKTAG_USERLOCK = 7,
    LOCKTAG_ADVISORY = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
impl ::std::default::Default for LOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
impl ::std::default::Default for LOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
impl ::std::default::Default for PROCLOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
impl ::std::default::Default for PROCLOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
impl ::std::default::Default for LOCALLOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum ResourceOwnerData { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut ResourceOwnerData,
    pub nLocks: int64,
}
impl ::std::default::Default for LOCALLOCKOWNER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub hashcode: uint32,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub holdsStrongLockCount: bool_,
    pub lockOwners: *mut LOCALLOCKOWNER,
}
impl ::std::default::Default for LOCALLOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub fastpath: bool_,
}
impl ::std::default::Default for LockInstanceData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: *mut LockInstanceData,
}
impl ::std::default::Default for LockData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LockAcquireResult {
    LOCKACQUIRE_NOT_AVAIL = 0,
    LOCKACQUIRE_OK = 1,
    LOCKACQUIRE_ALREADY_HELD = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum DeadLockState {
    DS_NOT_YET_CHECKED = 0,
    DS_NO_DEADLOCK = 1,
    DS_SOFT_DEADLOCK = 2,
    DS_HARD_DEADLOCK = 3,
    DS_BLOCKED_BY_AUTOVACUUM = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
impl ::std::default::Default for xl_standby_lock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: [bitmapword; 1usize],
}
impl ::std::default::Default for Bitmapset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum BMS_Comparison {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum BMS_Membership {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
pub type Buffer = ::std::os::raw::c_int;
pub enum BufferAccessStrategyData { }
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
pub type Snapshot = *mut SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<extern "C" fn(tuple: HeapTupleHeader,
                                        snapshot: Snapshot, buffer: Buffer)
                              -> bool_>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxcnt: int32,
    pub subxip: *mut TransactionId,
    pub suboverflowed: bool_,
    pub takenDuringRecovery: bool_,
    pub copied: bool_,
    pub curcid: CommandId,
    pub active_count: uint32,
    pub regd_count: uint32,
}
impl ::std::default::Default for SnapshotData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum HTSU_Result {
    HeapTupleMayBeUpdated = 0,
    HeapTupleInvisible = 1,
    HeapTupleSelfUpdated = 2,
    HeapTupleUpdated = 3,
    HeapTupleBeingUpdated = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
impl ::std::default::Default for IndexBuildResult {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: bool_,
    pub estimated_count: bool_,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
impl ::std::default::Default for IndexVacuumInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool_,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
impl ::std::default::Default for IndexBulkDeleteResult {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexBulkDeleteCallback =
    ::std::option::Option<unsafe extern "C" fn(itemptr: ItemPointer,
                                               state:
                                                   *mut ::std::os::raw::c_void)
                              -> bool_>;
pub enum IndexScanDescData { }
pub type IndexScanDesc = *mut IndexScanDescData;
pub enum SysScanDescData { }
pub type SysScanDesc = *mut SysScanDescData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum IndexUniqueCheck {
    UNIQUE_CHECK_NO = 0,
    UNIQUE_CHECK_YES = 1,
    UNIQUE_CHECK_PARTIAL = 2,
    UNIQUE_CHECK_EXISTING = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
impl ::std::default::Default for Alias {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum InhOption { INH_NO = 0, INH_YES = 1, INH_DEFAULT = 2, }
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inhOpt: InhOption,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for RangeVar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool_,
}
impl ::std::default::Default for IntoClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Expr {
    pub type_: NodeTag,
}
impl ::std::default::Default for Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Var {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool_,
    pub constbyval: bool_,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum ParamKind { PARAM_EXTERN = 0, PARAM_EXEC = 1, PARAM_SUBLINK = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggstar: bool_,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Aggref {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub winref: Index,
    pub winstar: bool_,
    pub winagg: bool_,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for WindowFunc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl ::std::default::Default for ArrayRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool_,
    pub funcvariadic: bool_,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for FuncExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for NamedArgExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool_,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for OpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool_,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ScalarArrayOpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum BoolExprType { AND_EXPR = 0, OR_EXPR = 1, NOT_EXPR = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for BoolExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    ARRAY_SUBLINK = 5,
    CTE_SUBLINK = 6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for SubLink {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool_,
    pub unknownEqFalse: bool_,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl ::std::default::Default for SubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl ::std::default::Default for AlternativeSubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl ::std::default::Default for FieldSelect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl ::std::default::Default for FieldStore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for RelabelType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CoerceViaIO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: bool_,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ArrayCoerceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ConvertRowtypeExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CollateExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CaseExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CaseWhen {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl ::std::default::Default for CaseTestExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool_,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for RowExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl ::std::default::Default for RowCompareExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CoalesceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum MinMaxOp { IS_GREATEST = 0, IS_LEAST = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for MinMaxExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum XmlOptionType { XMLOPTION_DOCUMENT = 0, XMLOPTION_CONTENT = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for XmlExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum NullTestType { IS_NULL = 0, IS_NOT_NULL = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool_,
}
impl ::std::default::Default for NullTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
}
impl ::std::default::Default for BooleanTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CoerceToDomain {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CoerceToDomainValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for SetToDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
impl ::std::default::Default for CurrentOfExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool_,
}
impl ::std::default::Default for TargetEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for RangeTblRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for JoinExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl ::std::default::Default for FromExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
impl ::std::default::Default for flock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
impl ::std::default::Default for stat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
impl ::std::default::Default for PageXLogRecPtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: [ItemIdData; 1usize],
}
impl ::std::default::Default for PageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageHeader = *mut PageHeaderData;
pub enum BulkInsertStateData { }
pub type BulkInsertState = *mut BulkInsertStateData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LockTupleMode {
    LockTupleKeyShare = 0,
    LockTupleShare = 1,
    LockTupleNoKeyExclusive = 2,
    LockTupleExclusive = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapUpdateFailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
}
impl ::std::default::Default for HeapUpdateFailureData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum HeapScanDescData { }
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
impl ::std::default::Default for timezone {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __timezone_ptr_t = *mut timezone;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
impl ::std::default::Default for itimerval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __itimer_which_t = ::std::os::raw::c_int;
pub type instr_time = timeval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
impl ::std::default::Default for BufferUsage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum InstrumentOption {
    INSTRUMENT_TIMER = 1,
    INSTRUMENT_BUFFERS = 2,
    INSTRUMENT_ROWS = 4,
    INSTRUMENT_ALL = 2147483647,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Instrumentation {
    pub need_timer: bool_,
    pub need_bufusage: bool_,
    pub running: bool_,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
}
impl ::std::default::Default for Instrumentation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum ParseState { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool_,
    pub pflags: uint16,
    pub ptype: Oid,
}
impl ::std::default::Default for ParamExternData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook =
    ::std::option::Option<extern "C" fn(params: ParamListInfo,
                                        paramid: ::std::os::raw::c_int)>;
pub type ParserSetupHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub numParams: ::std::os::raw::c_int,
    pub params: [ParamExternData; 1usize],
}
impl ::std::default::Default for ParamListInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool_,
}
impl ::std::default::Default for ParamExecData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint32,
    pub hasReturning: bool_,
    pub hasModifyingCTE: bool_,
    pub canSetTag: bool_,
    pub transientPlan: bool_,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub resultRelations: *mut List,
    pub utilityStmt: *mut Node,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
}
impl ::std::default::Default for PlannedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
impl ::std::default::Default for Plan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
impl ::std::default::Default for Result {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub resultRelations: *mut List,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub plans: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl ::std::default::Default for ModifyTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Append {
    pub plan: Plan,
    pub appendplans: *mut List,
}
impl ::std::default::Default for Append {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeAppend {
    pub plan: Plan,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
impl ::std::default::Default for MergeAppend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
impl ::std::default::Default for RecursiveUnion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
impl ::std::default::Default for BitmapAnd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapOr {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
impl ::std::default::Default for BitmapOr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
impl ::std::default::Default for Scan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SeqScan = Scan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderdir: ScanDirection,
}
impl ::std::default::Default for IndexScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
impl ::std::default::Default for IndexOnlyScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
impl ::std::default::Default for BitmapIndexScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
impl ::std::default::Default for BitmapHeapScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
impl ::std::default::Default for TidScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
}
impl ::std::default::Default for SubqueryScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FunctionScan {
    pub scan: Scan,
    pub funcexpr: *mut Node,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
}
impl ::std::default::Default for FunctionScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
impl ::std::default::Default for ValuesScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
impl ::std::default::Default for CteScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
impl ::std::default::Default for WorkTableScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignScan {
    pub scan: Scan,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fsSystemCol: bool_,
}
impl ::std::default::Default for ForeignScan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub joinqual: *mut List,
}
impl ::std::default::Default for Join {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
impl ::std::default::Default for NestLoop {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
impl ::std::default::Default for NestLoopParam {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeJoin {
    pub join: Join,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool_,
}
impl ::std::default::Default for MergeJoin {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
}
impl ::std::default::Default for HashJoin {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Material {
    pub plan: Plan,
}
impl ::std::default::Default for Material {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
impl ::std::default::Default for Sort {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
}
impl ::std::default::Default for Group {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum AggStrategy { AGG_PLAIN = 0, AGG_SORTED = 1, AGG_HASHED = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub aggParams: *mut Bitmapset,
}
impl ::std::default::Default for Agg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
}
impl ::std::default::Default for WindowAgg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
}
impl ::std::default::Default for Unique {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Hash {
    pub plan: Plan,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool_,
    pub skewColType: Oid,
    pub skewColTypmod: int32,
}
impl ::std::default::Default for Hash {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SetOpCmd {
    SETOPCMD_INTERSECT = 0,
    SETOPCMD_INTERSECT_ALL = 1,
    SETOPCMD_EXCEPT = 2,
    SETOPCMD_EXCEPT_ALL = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SetOpStrategy { SETOP_SORTED = 0, SETOP_HASHED = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
impl ::std::default::Default for SetOp {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl ::std::default::Default for LockRows {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
impl ::std::default::Default for Limit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum RowMarkType {
    ROW_MARK_EXCLUSIVE = 0,
    ROW_MARK_NOKEYEXCLUSIVE = 1,
    ROW_MARK_SHARE = 2,
    ROW_MARK_KEYSHARE = 3,
    ROW_MARK_REFERENCE = 4,
    ROW_MARK_COPY = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub noWait: bool_,
    pub isParent: bool_,
}
impl ::std::default::Default for PlanRowMark {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
impl ::std::default::Default for PlanInvalItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool_,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool_,
    pub tginitdeferred: bool_,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Trigger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool_,
    pub trig_insert_after_row: bool_,
    pub trig_insert_instead_row: bool_,
    pub trig_insert_before_statement: bool_,
    pub trig_insert_after_statement: bool_,
    pub trig_update_before_row: bool_,
    pub trig_update_after_row: bool_,
    pub trig_update_instead_row: bool_,
    pub trig_update_before_statement: bool_,
    pub trig_update_after_statement: bool_,
    pub trig_delete_before_row: bool_,
    pub trig_delete_after_row: bool_,
    pub trig_delete_instead_row: bool_,
    pub trig_delete_before_statement: bool_,
    pub trig_delete_after_statement: bool_,
    pub trig_truncate_before_statement: bool_,
    pub trig_truncate_after_statement: bool_,
}
impl ::std::default::Default for TriggerDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortSupport = *mut SortSupportData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool_,
    pub ssup_nulls_first: bool_,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<extern "C" fn(x: Datum, y: Datum,
                                                        ssup: SortSupport)
                                              -> ::std::os::raw::c_int>,
}
impl ::std::default::Default for SortSupportData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_isempty: bool_,
    pub tts_shouldFree: bool_,
    pub tts_shouldFreeMin: bool_,
    pub tts_slow: bool_,
    pub tts_tuple: HeapTuple,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_mcxt: MemoryContext,
    pub tts_buffer: Buffer,
    pub tts_nvalid: ::std::os::raw::c_int,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool_,
    pub tts_mintuple: MinimalTuple,
    pub tts_minhdr: HeapTupleData,
    pub tts_off: ::std::os::raw::c_long,
}
impl ::std::default::Default for TupleTableSlot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Tuplestorestate { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_KeyAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut List,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_Unique: bool_,
    pub ii_ReadyForInserts: bool_,
    pub ii_Concurrent: bool_,
    pub ii_BrokenHotChain: bool_,
}
impl ::std::default::Default for IndexInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExprContextCallbackFunction =
    ::std::option::Option<extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
impl ::std::default::Default for ExprContext_CB {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool_,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool_,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool_,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
impl ::std::default::Default for ExprContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum ExprDoneCond {
    ExprSingleResult = 0,
    ExprMultipleResult = 1,
    ExprEndResult = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SetFunctionReturnMode {
    SFRM_ValuePerCall = 1,
    SFRM_Materialize = 2,
    SFRM_Materialize_Random = 4,
    SFRM_Materialize_Preferred = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
impl ::std::default::Default for ReturnSetInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_targetlist: *mut List,
    pub pi_exprContext: *mut ExprContext,
    pub pi_slot: *mut TupleTableSlot,
    pub pi_itemIsDone: *mut ExprDoneCond,
    pub pi_directMap: bool_,
    pub pi_numSimpleVars: ::std::os::raw::c_int,
    pub pi_varSlotOffsets: *mut ::std::os::raw::c_int,
    pub pi_varNumbers: *mut ::std::os::raw::c_int,
    pub pi_varOutputCols: *mut ::std::os::raw::c_int,
    pub pi_lastInnerVar: ::std::os::raw::c_int,
    pub pi_lastOuterVar: ::std::os::raw::c_int,
    pub pi_lastScanVar: ::std::os::raw::c_int,
}
impl ::std::default::Default for ProjectionInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
    pub jf_junkAttNo: AttrNumber,
}
impl ::std::default::Default for JunkFilter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut List,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_ConstraintExprs: *mut *mut List,
    pub ri_junkFilter: *mut JunkFilter,
    pub ri_projectReturning: *mut ProjectionInfo,
}
impl ::std::default::Default for ResultRelInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut ResultRelInfo,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: *mut ResultRelInfo,
    pub es_trig_target_relations: *mut List,
    pub es_trig_tuple_slot: *mut TupleTableSlot,
    pub es_trig_oldtup_slot: *mut TupleTableSlot,
    pub es_trig_newtup_slot: *mut TupleTableSlot,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_rowMarks: *mut List,
    pub es_processed: uint32,
    pub es_lastoid: Oid,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool_,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epqTuple: *mut HeapTuple,
    pub es_epqTupleSet: *mut bool_,
    pub es_epqScanDone: *mut bool_,
}
impl ::std::default::Default for EState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub noWait: bool_,
    pub curCtid: ItemPointerData,
}
impl ::std::default::Default for ExecRowMark {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
impl ::std::default::Default for ExecAuxRowMark {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
}
impl ::std::default::Default for TupleHashEntryData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TupleHashTableData {
    pub hashtab: *mut HTAB,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
}
impl ::std::default::Default for TupleHashTableData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleHashIterator = HASH_SEQ_STATUS;
pub type ExprStateEvalFunc =
    ::std::option::Option<unsafe extern "C" fn(expression: *mut ExprState,
                                               econtext: *mut ExprContext,
                                               isNull: *mut bool_,
                                               isDone: *mut ExprDoneCond)
                              -> Datum>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub evalfunc: ExprStateEvalFunc,
}
impl ::std::default::Default for ExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GenericExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
}
impl ::std::default::Default for GenericExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WholeRowVarExprState {
    pub xprstate: ExprState,
    pub parent: *mut PlanState,
    pub wrv_junkFilter: *mut JunkFilter,
    pub wrv_tupdesc: TupleDesc,
}
impl ::std::default::Default for WholeRowVarExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AggrefExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub aggno: ::std::os::raw::c_int,
}
impl ::std::default::Default for AggrefExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowFuncExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub wfuncno: ::std::os::raw::c_int,
}
impl ::std::default::Default for WindowFuncExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayRefExprState {
    pub xprstate: ExprState,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut ExprState,
    pub refassgnexpr: *mut ExprState,
    pub refattrlength: int16,
    pub refelemlength: int16,
    pub refelembyval: bool_,
    pub refelemalign: ::std::os::raw::c_char,
}
impl ::std::default::Default for ArrayRefExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FuncExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool_,
    pub setArgsValid: bool_,
    pub setHasSetArg: bool_,
    pub shutdown_reg: bool_,
    pub fcinfo_data: FunctionCallInfoData,
}
impl ::std::default::Default for FuncExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScalarArrayOpExprState {
    pub fxprstate: FuncExprState,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
}
impl ::std::default::Default for ScalarArrayOpExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BoolExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
}
impl ::std::default::Default for BoolExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubPlanState {
    pub xprstate: ExprState,
    pub planstate: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool_,
    pub havenullrows: bool_,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
}
impl ::std::default::Default for SubPlanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlternativeSubPlanState {
    pub xprstate: ExprState,
    pub subplans: *mut List,
    pub active: ::std::os::raw::c_int,
}
impl ::std::default::Default for AlternativeSubPlanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FieldSelectState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub argdesc: TupleDesc,
}
impl ::std::default::Default for FieldSelectState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FieldStoreState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub newvals: *mut List,
    pub argdesc: TupleDesc,
}
impl ::std::default::Default for FieldStoreState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoerceViaIOState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub outfunc: FmgrInfo,
    pub infunc: FmgrInfo,
    pub intypioparam: Oid,
}
impl ::std::default::Default for CoerceViaIOState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum ArrayMapState { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayCoerceExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub resultelemtype: Oid,
    pub elemfunc: FmgrInfo,
    pub amstate: *mut ArrayMapState,
}
impl ::std::default::Default for ArrayCoerceExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum TupleConversionMap { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConvertRowtypeExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub map: *mut TupleConversionMap,
    pub initialized: bool_,
}
impl ::std::default::Default for ConvertRowtypeExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub args: *mut List,
    pub defresult: *mut ExprState,
}
impl ::std::default::Default for CaseExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseWhenState {
    pub xprstate: ExprState,
    pub expr: *mut ExprState,
    pub result: *mut ExprState,
}
impl ::std::default::Default for CaseWhenState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArrayExprState {
    pub xprstate: ExprState,
    pub elements: *mut List,
    pub elemlength: int16,
    pub elembyval: bool_,
    pub elemalign: ::std::os::raw::c_char,
}
impl ::std::default::Default for ArrayExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RowExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub tupdesc: TupleDesc,
}
impl ::std::default::Default for RowExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RowCompareExprState {
    pub xprstate: ExprState,
    pub largs: *mut List,
    pub rargs: *mut List,
    pub funcs: *mut FmgrInfo,
    pub collations: *mut Oid,
}
impl ::std::default::Default for RowCompareExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoalesceExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
}
impl ::std::default::Default for CoalesceExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MinMaxExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub cfunc: FmgrInfo,
}
impl ::std::default::Default for MinMaxExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmlExprState {
    pub xprstate: ExprState,
    pub named_args: *mut List,
    pub args: *mut List,
}
impl ::std::default::Default for XmlExprState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NullTestState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub argdesc: TupleDesc,
}
impl ::std::default::Default for NullTestState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CoerceToDomainState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub constraints: *mut List,
}
impl ::std::default::Default for CoerceToDomainState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum DomainConstraintType {
    DOM_CONSTRAINT_NOTNULL = 0,
    DOM_CONSTRAINT_CHECK = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut ExprState,
}
impl ::std::default::Default for DomainConstraintState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub instrument: *mut Instrumentation,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub ps_TupFromTlist: bool_,
}
impl ::std::default::Default for PlanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EPQState {
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub origslot: *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl ::std::default::Default for EPQState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool_,
    pub rs_checkqual: bool_,
}
impl ::std::default::Default for ResultState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub mt_done: bool_,
    pub mt_plans: *mut *mut PlanState,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub mt_arowmarks: *mut *mut List,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool_,
}
impl ::std::default::Default for ModifyTableState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
}
impl ::std::default::Default for AppendState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum binaryheap { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool_,
}
impl ::std::default::Default for MergeAppendState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool_,
    pub intermediate_empty: bool_,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
impl ::std::default::Default for RecursiveUnionState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl ::std::default::Default for BitmapAndState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl ::std::default::Default for BitmapOrState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: HeapScanDesc,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
impl ::std::default::Default for ScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SeqScanState = ScanState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: ScanKey,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool_,
}
impl ::std::default::Default for IndexRuntimeKeyInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexArrayKeyInfo {
    pub scan_key: ScanKey,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool_,
}
impl ::std::default::Default for IndexArrayKeyInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut List,
    pub iss_ScanKeys: ScanKey,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: ScanKey,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool_,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: IndexScanDesc,
}
impl ::std::default::Default for IndexScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: *mut List,
    pub ioss_ScanKeys: ScanKey,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: ScanKey,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool_,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: IndexScanDesc,
    pub ioss_VMBuffer: Buffer,
    pub ioss_HeapFetches: ::std::os::raw::c_long,
}
impl ::std::default::Default for IndexOnlyScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: ScanKey,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool_,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: IndexScanDesc,
}
impl ::std::default::Default for BitmapIndexScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut List,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
}
impl ::std::default::Default for BitmapHeapScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidquals: *mut List,
    pub tss_isCurrentOf: bool_,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_MarkTidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
impl ::std::default::Default for TidScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
impl ::std::default::Default for SubqueryScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub tupdesc: TupleDesc,
    pub tuplestorestate: *mut Tuplestorestate,
    pub funcexpr: *mut ExprState,
    pub argcontext: MemoryContext,
}
impl ::std::default::Default for FunctionScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
    pub marked_idx: ::std::os::raw::c_int,
}
impl ::std::default::Default for ValuesScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool_,
}
impl ::std::default::Default for CteScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
impl ::std::default::Default for WorkTableScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for ForeignScanState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub joinqual: *mut List,
}
impl ::std::default::Default for JoinState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool_,
    pub nl_MatchedOuter: bool_,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
impl ::std::default::Default for NestLoopState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum MergeJoinClauseData { }
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_ExtraMarks: bool_,
    pub mj_ConstFalseJoin: bool_,
    pub mj_FillOuter: bool_,
    pub mj_FillInner: bool_,
    pub mj_MatchedOuter: bool_,
    pub mj_MatchedInner: bool_,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
impl ::std::default::Default for MergeJoinState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum HashJoinTupleData { }
pub type HashJoinTuple = *mut HashJoinTupleData;
pub enum HashJoinTableData { }
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut List,
    pub hj_OuterHashKeys: *mut List,
    pub hj_InnerHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool_,
    pub hj_OuterNotEmpty: bool_,
}
impl ::std::default::Default for HashJoinState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool_,
    pub tuplestorestate: *mut Tuplestorestate,
}
impl ::std::default::Default for MaterialState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool_,
    pub bounded: bool_,
    pub bound: int64,
    pub sort_Done: bool_,
    pub bounded_Done: bool_,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for SortState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunctions: *mut FmgrInfo,
    pub grp_done: bool_,
}
impl ::std::default::Default for GroupState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum AggStatePerAggData { }
pub type AggStatePerAgg = *mut AggStatePerAggData;
pub enum AggStatePerGroupData { }
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub peragg: AggStatePerAgg,
    pub aggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub agg_done: bool_,
    pub pergroup: AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub hashslot: *mut TupleTableSlot,
    pub hash_needed: *mut List,
    pub table_filled: bool_,
    pub hashiter: TupleHashIterator,
}
impl ::std::default::Default for AggState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum WindowStatePerFuncData { }
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
pub enum WindowStatePerAggData { }
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
pub enum WindowObjectData { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunctions: *mut FmgrInfo,
    pub ordEqfunctions: *mut FmgrInfo,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub all_first: bool_,
    pub all_done: bool_,
    pub partition_spooled: bool_,
    pub more_partitions: bool_,
    pub framehead_valid: bool_,
    pub frametail_valid: bool_,
    pub first_part_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
impl ::std::default::Default for WindowAggState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
}
impl ::std::default::Default for UniqueState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
}
impl ::std::default::Default for HashState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum SetOpStatePerGroupData { }
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool_,
    pub numOutput: ::std::os::raw::c_long,
    pub tempContext: MemoryContext,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool_,
    pub hashiter: TupleHashIterator,
}
impl ::std::default::Default for SetOpState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
}
impl ::std::default::Default for LockRowsState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LimitStateCond {
    LIMIT_INITIAL = 0,
    LIMIT_RESCAN = 1,
    LIMIT_EMPTY = 2,
    LIMIT_INWINDOW = 3,
    LIMIT_SUBPLANEOF = 4,
    LIMIT_WINDOWEND = 5,
    LIMIT_WINDOWSTART = 6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool_,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
}
impl ::std::default::Default for LimitState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Value {
    pub type_: NodeTag,
    pub val: ValUnion,
}
impl ::std::default::Default for Value {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValUnion {
    pub _bindgen_data_: [u64; 1usize],
}
impl ValUnion {
    pub unsafe fn ival(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut *mut ::std::os::raw::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for ValUnion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type AclMode = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: bool_,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool_,
    pub hasWindowFuncs: bool_,
    pub hasSubLinks: bool_,
    pub hasDistinctOn: bool_,
    pub hasRecursive: bool_,
    pub hasModifyingCTE: bool_,
    pub hasForUpdate: bool_,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
}
impl ::std::default::Default for Query {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool_,
    pub pct_type: bool_,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for TypeName {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ColumnRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ParamRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_AND = 1,
    AEXPR_OR = 2,
    AEXPR_NOT = 3,
    AEXPR_OP_ANY = 4,
    AEXPR_OP_ALL = 5,
    AEXPR_DISTINCT = 6,
    AEXPR_NULLIF = 7,
    AEXPR_OF = 8,
    AEXPR_IN = 9,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for A_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for A_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for TypeCast {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for CollateClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_star: bool_,
    pub agg_distinct: bool_,
    pub func_variadic: bool_,
    pub over: *mut WindowDef,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for FuncCall {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Star {
    pub type_: NodeTag,
}
impl ::std::default::Default for A_Star {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl ::std::default::Default for A_Indices {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl ::std::default::Default for A_Indirection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for A_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for ResTarget {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for SortBy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for WindowDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl ::std::default::Default for RangeSubselect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub funccallnode: *mut Node,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl ::std::default::Default for RangeFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool_,
    pub is_not_null: bool_,
    pub is_from_type: bool_,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
}
impl ::std::default::Default for ColumnDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
impl ::std::default::Default for TableLikeClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum TableLikeOption {
    CREATE_TABLE_LIKE_DEFAULTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_INDEXES = 4,
    CREATE_TABLE_LIKE_STORAGE = 8,
    CREATE_TABLE_LIKE_COMMENTS = 16,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl ::std::default::Default for IndexElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
}
impl ::std::default::Default for DefElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum LockClauseStrength {
    LCS_FORKEYSHARE = 0,
    LCS_FORSHARE = 1,
    LCS_FORNOKEYUPDATE = 2,
    LCS_FORUPDATE = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub noWait: bool_,
}
impl ::std::default::Default for LockingClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for XmlSerialize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_VALUES = 4,
    RTE_CTE = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub subquery: *mut Query,
    pub security_barrier: bool_,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub funcexpr: *mut Node,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub values_lists: *mut List,
    pub values_collations: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool_,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool_,
    pub inh: bool_,
    pub inFromCl: bool_,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub modifiedCols: *mut Bitmapset,
}
impl ::std::default::Default for RangeTblEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool_,
    pub hashable: bool_,
}
impl ::std::default::Default for SortGroupClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: bool_,
}
impl ::std::default::Default for WindowClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub noWait: bool_,
    pub pushedDown: bool_,
}
impl ::std::default::Default for RowMarkClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool_,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for WithClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool_,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl ::std::default::Default for CommonTableExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for InsertStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for DeleteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for UpdateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
impl ::std::default::Default for SelectStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl ::std::default::Default for SetOperationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum ObjectType {
    OBJECT_AGGREGATE = 0,
    OBJECT_ATTRIBUTE = 1,
    OBJECT_CAST = 2,
    OBJECT_COLUMN = 3,
    OBJECT_CONSTRAINT = 4,
    OBJECT_COLLATION = 5,
    OBJECT_CONVERSION = 6,
    OBJECT_DATABASE = 7,
    OBJECT_DOMAIN = 8,
    OBJECT_EVENT_TRIGGER = 9,
    OBJECT_EXTENSION = 10,
    OBJECT_FDW = 11,
    OBJECT_FOREIGN_SERVER = 12,
    OBJECT_FOREIGN_TABLE = 13,
    OBJECT_FUNCTION = 14,
    OBJECT_INDEX = 15,
    OBJECT_LANGUAGE = 16,
    OBJECT_LARGEOBJECT = 17,
    OBJECT_MATVIEW = 18,
    OBJECT_OPCLASS = 19,
    OBJECT_OPERATOR = 20,
    OBJECT_OPFAMILY = 21,
    OBJECT_ROLE = 22,
    OBJECT_RULE = 23,
    OBJECT_SCHEMA = 24,
    OBJECT_SEQUENCE = 25,
    OBJECT_TABLE = 26,
    OBJECT_TABLESPACE = 27,
    OBJECT_TRIGGER = 28,
    OBJECT_TSCONFIGURATION = 29,
    OBJECT_TSDICTIONARY = 30,
    OBJECT_TSPARSER = 31,
    OBJECT_TSTEMPLATE = 32,
    OBJECT_TYPE = 33,
    OBJECT_VIEW = 34,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authid: *mut ::std::os::raw::c_char,
    pub schemaElts: *mut List,
    pub if_not_exists: bool_,
}
impl ::std::default::Default for CreateSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum DropBehavior { DROP_RESTRICT = 0, DROP_CASCADE = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_SetStatistics = 6,
    AT_SetOptions = 7,
    AT_ResetOptions = 8,
    AT_SetStorage = 9,
    AT_DropColumn = 10,
    AT_DropColumnRecurse = 11,
    AT_AddIndex = 12,
    AT_ReAddIndex = 13,
    AT_AddConstraint = 14,
    AT_AddConstraintRecurse = 15,
    AT_ReAddConstraint = 16,
    AT_ValidateConstraint = 17,
    AT_ValidateConstraintRecurse = 18,
    AT_ProcessedConstraint = 19,
    AT_AddIndexConstraint = 20,
    AT_DropConstraint = 21,
    AT_DropConstraintRecurse = 22,
    AT_AlterColumnType = 23,
    AT_AlterColumnGenericOptions = 24,
    AT_ChangeOwner = 25,
    AT_ClusterOn = 26,
    AT_DropCluster = 27,
    AT_AddOids = 28,
    AT_AddOidsRecurse = 29,
    AT_DropOids = 30,
    AT_SetTableSpace = 31,
    AT_SetRelOptions = 32,
    AT_ResetRelOptions = 33,
    AT_ReplaceRelOptions = 34,
    AT_EnableTrig = 35,
    AT_EnableAlwaysTrig = 36,
    AT_EnableReplicaTrig = 37,
    AT_DisableTrig = 38,
    AT_EnableTrigAll = 39,
    AT_DisableTrigAll = 40,
    AT_EnableTrigUser = 41,
    AT_DisableTrigUser = 42,
    AT_EnableRule = 43,
    AT_EnableAlwaysRule = 44,
    AT_EnableReplicaRule = 45,
    AT_DisableRule = 46,
    AT_AddInherit = 47,
    AT_DropInherit = 48,
    AT_AddOf = 49,
    AT_DropOf = 50,
    AT_GenericOptions = 51,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterTableCmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum GrantObjectType {
    ACL_OBJECT_COLUMN = 0,
    ACL_OBJECT_RELATION = 1,
    ACL_OBJECT_SEQUENCE = 2,
    ACL_OBJECT_DATABASE = 3,
    ACL_OBJECT_DOMAIN = 4,
    ACL_OBJECT_FDW = 5,
    ACL_OBJECT_FOREIGN_SERVER = 6,
    ACL_OBJECT_FUNCTION = 7,
    ACL_OBJECT_LANGUAGE = 8,
    ACL_OBJECT_LARGEOBJECT = 9,
    ACL_OBJECT_NAMESPACE = 10,
    ACL_OBJECT_TABLESPACE = 11,
    ACL_OBJECT_TYPE = 12,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool_,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool_,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for GrantStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrivGrantee {
    pub type_: NodeTag,
    pub rolname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for PrivGrantee {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FuncWithArgs {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub funcargs: *mut List,
}
impl ::std::default::Default for FuncWithArgs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
impl ::std::default::Default for AccessPriv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool_,
    pub admin_opt: bool_,
    pub grantor: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for GrantRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl ::std::default::Default for AlterDefaultPrivilegesStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool_,
    pub is_program: bool_,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CopyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum VariableSetKind {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool_,
}
impl ::std::default::Default for VariableSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for VariableShowStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
}
impl ::std::default::Default for CreateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_CHECK = 3,
    CONSTR_PRIMARY = 4,
    CONSTR_UNIQUE = 5,
    CONSTR_EXCLUSION = 6,
    CONSTR_FOREIGN = 7,
    CONSTR_ATTR_DEFERRABLE = 8,
    CONSTR_ATTR_NOT_DEFERRABLE = 9,
    CONSTR_ATTR_DEFERRED = 10,
    CONSTR_ATTR_IMMEDIATE = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool_,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub skip_validation: bool_,
    pub initially_valid: bool_,
    pub old_pktable_oid: Oid,
}
impl ::std::default::Default for Constraint {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut ::std::os::raw::c_char,
    pub location: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for CreateTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
impl ::std::default::Default for DropTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool_,
}
impl ::std::default::Default for AlterTableSpaceOptionsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
    pub options: *mut List,
}
impl ::std::default::Default for CreateExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for AlterExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
}
impl ::std::default::Default for AlterExtensionContentsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for CreateFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for AlterFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CreateForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool_,
}
impl ::std::default::Default for AlterForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CreateForeignTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CreateUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for AlterUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
impl ::std::default::Default for DropUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool_,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: bool_,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub constrrel: *mut RangeVar,
}
impl ::std::default::Default for CreateTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl ::std::default::Default for CreateEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
impl ::std::default::Default for AlterEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool_,
}
impl ::std::default::Default for CreatePLangStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CreateRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
impl ::std::default::Default for AlterRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut ::std::os::raw::c_char,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::default::Default for AlterRoleSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool_,
}
impl ::std::default::Default for DropRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
}
impl ::std::default::Default for CreateSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool_,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
}
impl ::std::default::Default for DefineStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl ::std::default::Default for CreateDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool_,
}
impl ::std::default::Default for CreateOpClassStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut List,
    pub args: *mut List,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl ::std::default::Default for CreateOpClassItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for CreateOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool_,
    pub items: *mut List,
}
impl ::std::default::Default for AlterOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub arguments: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
    pub concurrent: bool_,
}
impl ::std::default::Default for DropStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool_,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for TruncateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub comment: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for CommentStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for SecLabelStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
impl ::std::default::Default for DeclareCursorStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for ClosePortalStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool_,
}
impl ::std::default::Default for FetchStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: bool_,
    pub primary: bool_,
    pub isconstraint: bool_,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub concurrent: bool_,
}
impl ::std::default::Default for IndexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
impl ::std::default::Default for CreateFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl ::std::default::Default for FunctionParameter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub func: *mut FuncWithArgs,
    pub actions: *mut List,
}
impl ::std::default::Default for AlterFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
impl ::std::default::Default for DoStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool_,
}
impl ::std::default::Default for InlineCodeBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
impl ::std::default::Default for RenameStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterObjectSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newowner: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for AlterOwnerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool_,
    pub actions: *mut List,
    pub replace: bool_,
}
impl ::std::default::Default for RuleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for NotifyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for ListenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for UnlistenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for TransactionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl ::std::default::Default for CompositeTypeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl ::std::default::Default for CreateEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl ::std::default::Default for CreateRangeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool_,
    pub skipIfExists: bool_,
}
impl ::std::default::Default for AlterEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool_,
    pub options: *mut List,
}
impl ::std::default::Default for ViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for LoadStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for CreatedbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for AlterDatabaseStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::default::Default for AlterDatabaseSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
impl ::std::default::Default for DropdbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: bool_,
}
impl ::std::default::Default for ClusterStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum VacuumOption {
    VACOPT_VACUUM = 1,
    VACOPT_ANALYZE = 2,
    VACOPT_VERBOSE = 4,
    VACOPT_FREEZE = 8,
    VACOPT_FULL = 16,
    VACOPT_NOWAIT = 32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
}
impl ::std::default::Default for VacuumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl ::std::default::Default for ExplainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: bool_,
}
impl ::std::default::Default for CreateTableAsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub skipData: bool_,
    pub relation: *mut RangeVar,
}
impl ::std::default::Default for RefreshMatViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
impl ::std::default::Default for CheckPointStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum DiscardMode { DISCARD_ALL = 0, DISCARD_PLANS = 1, DISCARD_TEMP = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
impl ::std::default::Default for DiscardStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool_,
}
impl ::std::default::Default for LockStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool_,
}
impl ::std::default::Default for ConstraintsSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub do_system: bool_,
    pub do_user: bool_,
}
impl ::std::default::Default for ReindexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool_,
}
impl ::std::default::Default for CreateConversionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut FuncWithArgs,
    pub context: CoercionContext,
    pub inout: bool_,
}
impl ::std::default::Default for CreateCastStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl ::std::default::Default for PrepareStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl ::std::default::Default for ExecuteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for DeallocateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for DropOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for ReassignOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for AlterTSDictionaryStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool_,
    pub replace: bool_,
    pub missing_ok: bool_,
}
impl ::std::default::Default for AlterTSConfigurationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Relids = *mut Bitmapset;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum CostSelector { STARTUP_COST = 0, TOTAL_COST = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
impl ::std::default::Default for QualCost {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AggClauseCosts {
    pub numAggs: ::std::os::raw::c_int,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub transCost: QualCost,
    pub finalCost: Cost,
    pub transitionSpace: Size,
}
impl ::std::default::Default for AggClauseCosts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub transientPlan: bool_,
}
impl ::std::default::Default for PlannerGlobal {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub simple_rel_array: *mut *mut RelOptInfo,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub all_baserels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub eq_classes: *mut List,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub lateral_info_list: *mut List,
    pub append_rel_list: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub minmax_aggs: *mut List,
    pub initial_rels: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: f64,
    pub tuple_fraction: f64,
    pub limit_tuples: f64,
    pub hasInheritedTarget: bool_,
    pub hasJoinRTEs: bool_,
    pub hasLateralRTEs: bool_,
    pub hasHavingQual: bool_,
    pub hasPseudoConstantQuals: bool_,
    pub hasRecursion: bool_,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_plan: *mut Plan,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub join_search_private: *mut ::std::os::raw::c_void,
    pub nullable_baserels: Relids,
}
impl ::std::default::Default for PlannerInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum RelOptKind {
    RELOPT_BASEREL = 0,
    RELOPT_JOINREL = 1,
    RELOPT_OTHER_MEMBER_REL = 2,
    RELOPT_DEADREL = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: Relids,
    pub rows: f64,
    pub width: ::std::os::raw::c_int,
    pub consider_startup: bool_,
    pub consider_param_startup: bool_,
    pub reltargetlist: *mut List,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub lateral_vars: *mut List,
    pub lateral_relids: Relids,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub allvisfrac: f64,
    pub subplan: *mut Plan,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_private: *mut ::std::os::raw::c_void,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool_,
}
impl ::std::default::Default for RelOptInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub indexkeys: *mut ::std::os::raw::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool_,
    pub nulls_first: *mut bool_,
    pub relam: Oid,
    pub amcostestimate: RegProcedure,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub predOK: bool_,
    pub unique: bool_,
    pub immediate: bool_,
    pub hypothetical: bool_,
    pub canreturn: bool_,
    pub amcanorderbyop: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amhasgettuple: bool_,
    pub amhasgetbitmap: bool_,
}
impl ::std::default::Default for IndexOptInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool_,
    pub ec_has_volatile: bool_,
    pub ec_below_outer_join: bool_,
    pub ec_broken: bool_,
    pub ec_sortref: Index,
    pub ec_merged: *mut EquivalenceClass,
}
impl ::std::default::Default for EquivalenceClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_nullable_relids: Relids,
    pub em_is_const: bool_,
    pub em_is_child: bool_,
    pub em_datatype: Oid,
}
impl ::std::default::Default for EquivalenceMember {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool_,
}
impl ::std::default::Default for PathKey {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: f64,
    pub ppi_clauses: *mut List,
}
impl ::std::default::Default for ParamPathInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub param_info: *mut ParamPathInfo,
    pub rows: f64,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
impl ::std::default::Default for Path {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexquals: *mut List,
    pub indexqualcols: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
impl ::std::default::Default for IndexPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
impl ::std::default::Default for BitmapHeapPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl ::std::default::Default for BitmapAndPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl ::std::default::Default for BitmapOrPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
impl ::std::default::Default for TidPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_private: *mut List,
}
impl ::std::default::Default for ForeignPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AppendPath {
    pub path: Path,
    pub subpaths: *mut List,
}
impl ::std::default::Default for AppendPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeAppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub limit_tuples: f64,
}
impl ::std::default::Default for MergeAppendPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResultPath {
    pub path: Path,
    pub quals: *mut List,
}
impl ::std::default::Default for ResultPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl ::std::default::Default for MaterialPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum UniquePathMethod {
    UNIQUE_PATH_NOOP = 0,
    UNIQUE_PATH_HASH = 1,
    UNIQUE_PATH_SORT = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
impl ::std::default::Default for UniquePath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
impl ::std::default::Default for JoinPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NestPath = JoinPath;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub materialize_inner: bool_,
}
impl ::std::default::Default for MergePath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::std::os::raw::c_int,
}
impl ::std::default::Default for HashPath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool_,
    pub outerjoin_delayed: bool_,
    pub can_join: bool_,
    pub pseudoconstant: bool_,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub outer_relids: Relids,
    pub nullable_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool_,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
}
impl ::std::default::Default for RestrictInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool_,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
impl ::std::default::Default for MergeScanSelCache {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
impl ::std::default::Default for PlaceHolderVar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType,
    pub lhs_strict: bool_,
    pub delay_upper_joins: bool_,
    pub join_quals: *mut List,
}
impl ::std::default::Default for SpecialJoinInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LateralJoinInfo {
    pub type_: NodeTag,
    pub lateral_lhs: Relids,
    pub lateral_rhs: Relids,
}
impl ::std::default::Default for LateralJoinInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub parent_reloid: Oid,
}
impl ::std::default::Default for AppendRelInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
impl ::std::default::Default for PlaceHolderInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
impl ::std::default::Default for MinMaxAggInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::std::os::raw::c_int,
}
impl ::std::default::Default for PlannerParamItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
impl ::std::default::Default for SemiAntiJoinFactors {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: f64,
    pub inner_rows: f64,
    pub outer_skip_rows: f64,
    pub inner_skip_rows: f64,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
}
impl ::std::default::Default for JoinCostWorkspace {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum ExplainState { }
pub type GetForeignRelSize_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPlan_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid,
                                               best_path: *mut ForeignPath,
                                               tlist: *mut List,
                                               scan_clauses: *mut List)
                              -> *mut ForeignScan>;
pub type BeginForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type IterateForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)
                              -> *mut TupleTableSlot>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type AddForeignUpdateTargets_function =
    ::std::option::Option<unsafe extern "C" fn(parsetree: *mut Query,
                                               target_rte: *mut RangeTblEntry,
                                               target_relation: Relation)>;
pub type PlanForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               plan: *mut ModifyTable,
                                               resultRelation: Index,
                                               subplan_index:
                                                   ::std::os::raw::c_int)
                              -> *mut List>;
pub type BeginForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type ExecForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignUpdate_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignDelete_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<extern "C" fn(rel: Relation)
                              -> ::std::os::raw::c_int>;
pub type ExplainForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               es: *mut ExplainState)>;
pub type ExplainForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               es: *mut ExplainState)>;
pub type AcquireSampleRowsFunc =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               elevel: ::std::os::raw::c_int,
                                               rows: *mut HeapTuple,
                                               targrows:
                                                   ::std::os::raw::c_int,
                                               totalrows: *mut f64,
                                               totaldeadrows: *mut f64)
                              -> ::std::os::raw::c_int>;
pub type AnalyzeForeignTable_function =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               func:
                                                   *mut AcquireSampleRowsFunc,
                                               totalpages: *mut BlockNumber)
                              -> bool_>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
}
impl ::std::default::Default for FdwRoutine {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum GenericOptionFlags { ServerOpt = 1, UserMappingOpt = 2, FdwOpt = 4, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
impl ::std::default::Default for ForeignDataWrapper {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub serverversion: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for ForeignServer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserMapping {
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl ::std::default::Default for UserMapping {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl ::std::default::Default for ForeignTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type query_pathkeys_callback =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               extra:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
impl ::std::default::Default for StringInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StringInfo = *mut StringInfoData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl ::std::default::Default for OpBtreeInterpretation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> int32>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormData_pg_am {
    pub amname: NameData,
    pub amstrategies: int16,
    pub amsupport: int16,
    pub amcanorder: bool_,
    pub amcanorderbyop: bool_,
    pub amcanbackward: bool_,
    pub amcanunique: bool_,
    pub amcanmulticol: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amstorage: bool_,
    pub amclusterable: bool_,
    pub ampredlocks: bool_,
    pub amkeytype: Oid,
    pub aminsert: regproc,
    pub ambeginscan: regproc,
    pub amgettuple: regproc,
    pub amgetbitmap: regproc,
    pub amrescan: regproc,
    pub amendscan: regproc,
    pub ammarkpos: regproc,
    pub amrestrpos: regproc,
    pub ambuild: regproc,
    pub ambuildempty: regproc,
    pub ambulkdelete: regproc,
    pub amvacuumcleanup: regproc,
    pub amcanreturn: regproc,
    pub amcostestimate: regproc,
    pub amoptions: regproc,
}
impl ::std::default::Default for FormData_pg_am {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub reltoastidxid: Oid,
    pub relhasindex: bool_,
    pub relisshared: bool_,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: bool_,
    pub relhaspkey: bool_,
    pub relhasrules: bool_,
    pub relhastriggers: bool_,
    pub relhassubclass: bool_,
    pub relispopulated: bool_,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl ::std::default::Default for FormData_pg_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: bool_,
    pub indisprimary: bool_,
    pub indisexclusion: bool_,
    pub indimmediate: bool_,
    pub indisclustered: bool_,
    pub indisvalid: bool_,
    pub indcheckxmin: bool_,
    pub indisready: bool_,
    pub indislive: bool_,
    pub indkey: int2vector,
}
impl ::std::default::Default for FormData_pg_index {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub attrno: AttrNumber,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool_,
}
impl ::std::default::Default for RewriteRule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl ::std::default::Default for RuleLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(i32)]
pub enum ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
impl ::std::default::Default for RelFileNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
impl ::std::default::Default for RelFileNodeBackend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl ::std::default::Default for LockRelId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
impl ::std::default::Default for LockInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelationAmInfo {
    pub aminsert: FmgrInfo,
    pub ambeginscan: FmgrInfo,
    pub amgettuple: FmgrInfo,
    pub amgetbitmap: FmgrInfo,
    pub amrescan: FmgrInfo,
    pub amendscan: FmgrInfo,
    pub ammarkpos: FmgrInfo,
    pub amrestrpos: FmgrInfo,
    pub amcanreturn: FmgrInfo,
}
impl ::std::default::Default for RelationAmInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum SMgrRelationData { }
pub enum PgStat_TableStatus { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool_,
    pub rd_isnailed: bool_,
    pub rd_isvalid: bool_,
    pub rd_indexvalid: ::std::os::raw::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_indexlist: *mut List,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_oidindex: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_am: Form_pg_am,
    pub rd_indexcxt: MemoryContext,
    pub rd_aminfo: *mut RelationAmInfo,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut PgStat_TableStatus,
}
impl ::std::default::Default for RelationData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AutoVacOpts {
    pub enabled: bool_,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_delay: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
impl ::std::default::Default for AutoVacOpts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AutoVacOpts2 {
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
}
impl ::std::default::Default for AutoVacOpts2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub security_barrier: bool_,
    pub autovacuum2: AutoVacOpts2,
}
impl ::std::default::Default for StdRdOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
    pub static mut stdin: *mut _IO_FILE;
    pub static mut stdout: *mut _IO_FILE;
    pub static mut stderr: *mut _IO_FILE;
    pub static mut sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
    pub static in6addr_any: in6_addr;
    pub static in6addr_loopback: in6_addr;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
    pub static mut Log_destination: ::std::os::raw::c_int;
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut assert_enabled: bool_;
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static mut MyBackendId: BackendId;
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
    pub static mut criticalRelcachesBuilt: bool_;
    pub static mut criticalSharedRelcachesBuilt: bool_;
    pub static mut pgBufferUsage: BufferUsage;
    pub static mut cursor_tuple_fraction: f64;
    pub static mut from_collapse_limit: ::std::os::raw::c_int;
    pub static mut join_collapse_limit: ::std::os::raw::c_int;
    pub static mut extra_float_digits: ::std::os::raw::c_int;
    pub static mut quote_all_identifiers: bool_;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub static mut no_such_variable: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: __gnuc_va_list, arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: size_t) -> size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: size_t,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut size_t) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                     __format: *const ::std::os::raw::c_char,
                     __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut size_t, __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                 __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: size_t,
                  __n: size_t, __s: *mut FILE) -> size_t;
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                          __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: size_t, __n: size_t, __stream: *mut FILE)
     -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn srandom(__seed: ::std::os::raw::c_uint);
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: size_t) -> *mut ::std::os::raw::c_char;
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn random_r(__buf: *mut random_data, __result: *mut int32_t)
     -> ::std::os::raw::c_int;
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: size_t, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn srand(__seed: ::std::os::raw::c_uint);
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn drand48() -> f64;
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn srand48(__seedval: ::std::os::raw::c_long);
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
    pub fn alloca(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: size_t, __size: size_t)
     -> ::std::os::raw::c_int;
    pub fn aligned_alloc(__alignment: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn at_quick_exit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn exit(__status: ::std::os::raw::c_int);
    pub fn quick_exit(__status: ::std::os::raw::c_int);
    pub fn _Exit(__status: ::std::os::raw::c_int);
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn clearenv() -> ::std::os::raw::c_int;
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: size_t,
                 __size: size_t, __compar: __compar_fn_t);
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: size_t) -> ::std::os::raw::c_int;
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: size_t) -> size_t;
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: size_t) -> size_t;
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *mut ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_ulong;
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t)
     -> size_t;
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
    pub fn setlocale(__category: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn localeconv() -> *mut lconv;
    pub fn newlocale(__category_mask: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char,
                     __base: __locale_t) -> __locale_t;
    pub fn duplocale(__dataset: __locale_t) -> __locale_t;
    pub fn freelocale(__dataset: __locale_t);
    pub fn uselocale(__dataset: __locale_t) -> __locale_t;
    pub fn gettext(__msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dgettext(__domainname: *const ::std::os::raw::c_char,
                    __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __dgettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dcgettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid: *const ::std::os::raw::c_char,
                     __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __dcgettext(__domainname: *const ::std::os::raw::c_char,
                       __msgid: *const ::std::os::raw::c_char,
                       __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ngettext(__msgid1: *const ::std::os::raw::c_char,
                    __msgid2: *const ::std::os::raw::c_char,
                    __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
    pub fn dngettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid1: *const ::std::os::raw::c_char,
                     __msgid2: *const ::std::os::raw::c_char,
                     __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
    pub fn dcngettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid1: *const ::std::os::raw::c_char,
                      __msgid2: *const ::std::os::raw::c_char,
                      __n: ::std::os::raw::c_ulong,
                      __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn textdomain(__domainname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bindtextdomain(__domainname: *const ::std::os::raw::c_char,
                          __dirname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bind_textdomain_codeset(__domainname:
                                       *const ::std::os::raw::c_char,
                                   __codeset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: size_t,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> ssize_t;
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: size_t,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> ssize_t;
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ntohl(__netlong: uint32_t) -> uint32_t;
    pub fn ntohs(__netshort: uint16_t) -> uint16_t;
    pub fn htonl(__hostlong: uint32_t) -> uint32_t;
    pub fn htons(__hostshort: uint16_t) -> uint16_t;
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
    pub fn endrpcent();
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
    pub fn getrpcent() -> *mut rpcent;
    pub fn getrpcbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut rpcent,
                          __buffer: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
    pub fn getrpcbynumber_r(__number: ::std::os::raw::c_int,
                            __result_buf: *mut rpcent,
                            __buffer: *mut ::std::os::raw::c_char,
                            __buflen: size_t, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
    pub fn getrpcent_r(__result_buf: *mut rpcent,
                       __buffer: *mut ::std::os::raw::c_char,
                       __buflen: size_t, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
    pub fn herror(__str: *const ::std::os::raw::c_char);
    pub fn hstrerror(__err_num: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
    pub fn endhostent();
    pub fn gethostent() -> *mut hostent;
    pub fn gethostbyaddr(__addr: *const ::std::os::raw::c_void,
                         __len: __socklen_t, __type: ::std::os::raw::c_int)
     -> *mut hostent;
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char)
     -> *mut hostent;
    pub fn gethostbyname2(__name: *const ::std::os::raw::c_char,
                          __af: ::std::os::raw::c_int) -> *mut hostent;
    pub fn gethostent_r(__result_buf: *mut hostent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                        __result: *mut *mut hostent,
                        __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyaddr_r(__addr: *const ::std::os::raw::c_void,
                           __len: __socklen_t, __type: ::std::os::raw::c_int,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyname_r(__name: *const ::std::os::raw::c_char,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyname2_r(__name: *const ::std::os::raw::c_char,
                            __af: ::std::os::raw::c_int,
                            __result_buf: *mut hostent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: size_t, __result: *mut *mut hostent,
                            __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
    pub fn endnetent();
    pub fn getnetent() -> *mut netent;
    pub fn getnetbyaddr(__net: uint32_t, __type: ::std::os::raw::c_int)
     -> *mut netent;
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
    pub fn getnetent_r(__result_buf: *mut netent,
                       __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                       __result: *mut *mut netent,
                       __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getnetbyaddr_r(__net: uint32_t, __type: ::std::os::raw::c_int,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getnetbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
    pub fn endservent();
    pub fn getservent() -> *mut servent;
    pub fn getservbyname(__name: *const ::std::os::raw::c_char,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
    pub fn getservbyport(__port: ::std::os::raw::c_int,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
    pub fn getservent_r(__result_buf: *mut servent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                        __result: *mut *mut servent) -> ::std::os::raw::c_int;
    pub fn getservbyname_r(__name: *const ::std::os::raw::c_char,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
    pub fn getservbyport_r(__port: ::std::os::raw::c_int,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
    pub fn endprotoent();
    pub fn getprotoent() -> *mut protoent;
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char)
     -> *mut protoent;
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
    pub fn getprotoent_r(__result_buf: *mut protoent,
                         __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                         __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
    pub fn getprotobyname_r(__name: *const ::std::os::raw::c_char,
                            __result_buf: *mut protoent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: size_t, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
    pub fn getprotobynumber_r(__proto: ::std::os::raw::c_int,
                              __result_buf: *mut protoent,
                              __buf: *mut ::std::os::raw::c_char,
                              __buflen: size_t, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn endnetgrent();
    pub fn getnetgrent(__hostp: *mut *mut ::std::os::raw::c_char,
                       __userp: *mut *mut ::std::os::raw::c_char,
                       __domainp: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn innetgr(__netgroup: *const ::std::os::raw::c_char,
                   __host: *const ::std::os::raw::c_char,
                   __user: *const ::std::os::raw::c_char,
                   __domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getnetgrent_r(__hostp: *mut *mut ::std::os::raw::c_char,
                         __userp: *mut *mut ::std::os::raw::c_char,
                         __domainp: *mut *mut ::std::os::raw::c_char,
                         __buffer: *mut ::std::os::raw::c_char,
                         __buflen: size_t) -> ::std::os::raw::c_int;
    pub fn rcmd(__ahost: *mut *mut ::std::os::raw::c_char,
                __rport: ::std::os::raw::c_ushort,
                __locuser: *const ::std::os::raw::c_char,
                __remuser: *const ::std::os::raw::c_char,
                __cmd: *const ::std::os::raw::c_char,
                __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rcmd_af(__ahost: *mut *mut ::std::os::raw::c_char,
                   __rport: ::std::os::raw::c_ushort,
                   __locuser: *const ::std::os::raw::c_char,
                   __remuser: *const ::std::os::raw::c_char,
                   __cmd: *const ::std::os::raw::c_char,
                   __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
    pub fn rexec(__ahost: *mut *mut ::std::os::raw::c_char,
                 __rport: ::std::os::raw::c_int,
                 __name: *const ::std::os::raw::c_char,
                 __pass: *const ::std::os::raw::c_char,
                 __cmd: *const ::std::os::raw::c_char,
                 __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rexec_af(__ahost: *mut *mut ::std::os::raw::c_char,
                    __rport: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __pass: *const ::std::os::raw::c_char,
                    __cmd: *const ::std::os::raw::c_char,
                    __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
    pub fn ruserok(__rhost: *const ::std::os::raw::c_char,
                   __suser: ::std::os::raw::c_int,
                   __remuser: *const ::std::os::raw::c_char,
                   __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn ruserok_af(__rhost: *const ::std::os::raw::c_char,
                      __suser: ::std::os::raw::c_int,
                      __remuser: *const ::std::os::raw::c_char,
                      __locuser: *const ::std::os::raw::c_char,
                      __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn iruserok(__raddr: uint32_t, __suser: ::std::os::raw::c_int,
                    __remuser: *const ::std::os::raw::c_char,
                    __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn iruserok_af(__raddr: *const ::std::os::raw::c_void,
                       __suser: ::std::os::raw::c_int,
                       __remuser: *const ::std::os::raw::c_char,
                       __locuser: *const ::std::os::raw::c_char,
                       __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rresvport_af(__alport: *mut ::std::os::raw::c_int,
                        __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn getaddrinfo(__name: *const ::std::os::raw::c_char,
                       __service: *const ::std::os::raw::c_char,
                       __req: *const addrinfo, __pai: *mut *mut addrinfo)
     -> ::std::os::raw::c_int;
    pub fn freeaddrinfo(__ai: *mut addrinfo);
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn getnameinfo(__sa: *const sockaddr, __salen: socklen_t,
                       __host: *mut ::std::os::raw::c_char,
                       __hostlen: socklen_t,
                       __serv: *mut ::std::os::raw::c_char,
                       __servlen: socklen_t, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setpwent();
    pub fn endpwent();
    pub fn getpwent() -> *mut passwd;
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
    pub fn putpwent(__p: *const passwd, __f: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
    pub fn getpwnam(__name: *const ::std::os::raw::c_char) -> *mut passwd;
    pub fn getpwent_r(__resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
    pub fn getpwuid_r(__uid: __uid_t, __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
    pub fn getpwnam_r(__name: *const ::std::os::raw::c_char,
                      __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
    pub fn fgetpwent_r(__stream: *mut FILE, __resultbuf: *mut passwd,
                       __buffer: *mut ::std::os::raw::c_char,
                       __buflen: size_t, __result: *mut *mut passwd)
     -> ::std::os::raw::c_int;
    pub fn pg_set_noblock(sock: pgsocket) -> bool_;
    pub fn pg_set_block(sock: pgsocket) -> bool_;
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> bool_;
    pub fn first_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn last_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn first_path_var_separator(pathlist: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn join_path_components(ret_path: *mut ::std::os::raw::c_char,
                                head: *const ::std::os::raw::c_char,
                                tail: *const ::std::os::raw::c_char);
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char)
     -> bool_;
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char)
     -> bool_;
    pub fn path_is_prefix_of_path(path1: *const ::std::os::raw::c_char,
                                  path2: *const ::std::os::raw::c_char)
     -> bool_;
    pub fn get_progname(argv0: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn get_share_path(my_exec_path: *const ::std::os::raw::c_char,
                          ret_path: *mut ::std::os::raw::c_char);
    pub fn get_etc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_include_path(my_exec_path: *const ::std::os::raw::c_char,
                            ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkginclude_path(my_exec_path: *const ::std::os::raw::c_char,
                               ret_path: *mut ::std::os::raw::c_char);
    pub fn get_includeserver_path(my_exec_path: *const ::std::os::raw::c_char,
                                  ret_path: *mut ::std::os::raw::c_char);
    pub fn get_lib_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkglib_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_locale_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_doc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_html_path(my_exec_path: *const ::std::os::raw::c_char,
                         ret_path: *mut ::std::os::raw::c_char);
    pub fn get_man_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> bool_;
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
    pub fn pgfnames(path: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
    pub fn set_pglocale_pgservice(argv0: *const ::std::os::raw::c_char,
                                  app: *const ::std::os::raw::c_char);
    pub fn find_my_exec(argv0: *const ::std::os::raw::c_char,
                        retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn find_other_exec(argv0: *const ::std::os::raw::c_char,
                           target: *const ::std::os::raw::c_char,
                           versionstr: *const ::std::os::raw::c_char,
                           retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
    pub fn pg_strcasecmp(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_strncasecmp(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: size_t)
     -> ::std::os::raw::c_int;
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn simple_prompt(prompt: *const ::std::os::raw::c_char,
                         maxlen: ::std::os::raw::c_int, echo: bool_)
     -> *mut ::std::os::raw::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: bool_)
     -> bool_;
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort) -> f64;
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
    pub fn fls(mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getpeereid(sock: ::std::os::raw::c_int, uid: *mut uid_t,
                      gid: *mut gid_t) -> ::std::os::raw::c_int;
    pub fn strlcat(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: size_t) -> size_t;
    pub fn strlcpy(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: size_t) -> size_t;
    pub fn pqStrerror(errnum: ::std::os::raw::c_int,
                      strerrbuf: *mut ::std::os::raw::c_char, buflen: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut passwd,
                      buffer: *mut ::std::os::raw::c_char, buflen: size_t,
                      result: *mut *mut passwd) -> ::std::os::raw::c_int;
    pub fn pqGethostbyname(name: *const ::std::os::raw::c_char,
                           resultbuf: *mut hostent,
                           buffer: *mut ::std::os::raw::c_char,
                           buflen: size_t, result: *mut *mut hostent,
                           herrno: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pg_qsort(base: *mut ::std::os::raw::c_void, nel: size_t,
                    elsize: size_t,
                    cmp:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
    pub fn pg_qsort_strcmp(a: *const ::std::os::raw::c_void,
                           b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn qsort_arg(base: *mut ::std::os::raw::c_void, nel: size_t,
                     elsize: size_t, cmp: qsort_arg_comparator,
                     arg: *mut ::std::os::raw::c_void);
    pub fn pg_get_encoding_from_locale(ctype: *const ::std::os::raw::c_char,
                                       write_message: bool_)
     -> ::std::os::raw::c_int;
    pub fn inet_net_ntop(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_void,
                         bits: ::std::os::raw::c_int,
                         dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_mkdir_p(path: *mut ::std::os::raw::c_char,
                      omode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn setjmp(__env: jmp_buf) -> ::std::os::raw::c_int;
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
    pub fn siglongjmp(__env: sigjmp_buf, __val: ::std::os::raw::c_int);
    pub fn errstart(elevel: ::std::os::raw::c_int,
                    filename: *const ::std::os::raw::c_char,
                    lineno: ::std::os::raw::c_int,
                    funcname: *const ::std::os::raw::c_char,
                    domain: *const ::std::os::raw::c_char) -> bool_;
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_plural(fmt_singular: *const ::std::os::raw::c_char,
                         fmt_plural: *const ::std::os::raw::c_char,
                         n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_plural(fmt_singular: *const ::std::os::raw::c_char,
                            fmt_plural: *const ::std::os::raw::c_char,
                            n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errhidestmt(hide_stmt: bool_) -> ::std::os::raw::c_int;
    pub fn errfunction(funcname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrquery(query: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn err_generic_string(field: ::std::os::raw::c_int,
                              str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn geterrcode() -> ::std::os::raw::c_int;
    pub fn geterrposition() -> ::std::os::raw::c_int;
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
    pub fn elog_start(filename: *const ::std::os::raw::c_char,
                      lineno: ::std::os::raw::c_int,
                      funcname: *const ::std::os::raw::c_char);
    pub fn elog_finish(elevel: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
    pub fn pre_format_elog_string(errnumber: ::std::os::raw::c_int,
                                  domain: *const ::std::os::raw::c_char);
    pub fn format_elog_string(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn EmitErrorReport();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData);
    pub fn FlushErrorState();
    pub fn ReThrowError(edata: *mut ErrorData);
    pub fn pg_re_throw();
    pub fn DebugFileOpen();
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn in_error_recursion_trouble() -> bool_;
    pub fn set_syslog_parameters(ident: *const ::std::os::raw::c_char,
                                 facility: ::std::os::raw::c_int);
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn repalloc(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pstrdup(in_: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pnstrdup(in_: *const ::std::os::raw::c_char, len: Size)
     -> *mut ::std::os::raw::c_char;
    pub fn DatumGetFloat4(X: Datum) -> float4;
    pub fn Float4GetDatum(X: float4) -> Datum;
    pub fn DatumGetFloat8(X: Datum) -> float8;
    pub fn Float8GetDatum(X: float8) -> Datum;
    pub fn ExceptionalCondition(conditionName: *const ::std::os::raw::c_char,
                                errorType: *const ::std::os::raw::c_char,
                                fileName: *const ::std::os::raw::c_char,
                                lineNumber: ::std::os::raw::c_int);
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> bool_;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut bool_);
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn nodeToString(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
    pub fn stringToNode(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn copyObject(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn equal(a: *const ::std::os::raw::c_void,
                 b: *const ::std::os::raw::c_void) -> bool_;
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::std::os::raw::c_void) -> *mut ListCell;
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::std::os::raw::c_int) -> *mut ListCell;
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List)
     -> *mut List;
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List)
     -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
    pub fn list_member(list: *const List,
                       datum: *const ::std::os::raw::c_void) -> bool_;
    pub fn list_member_ptr(list: *const List,
                           datum: *const ::std::os::raw::c_void) -> bool_;
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int)
     -> bool_;
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool_;
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_delete_ptr(list: *mut List,
                           datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_append_unique(list: *mut List,
                              datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List,
                                  datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_int(list: *mut List,
                                  datum: ::std::os::raw::c_int) -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_free(list: *mut List);
    pub fn list_free_deep(list: *mut List);
    pub fn list_copy(list: *const List) -> *mut List;
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int)
     -> *mut List;
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int,
                                   hasoid: bool_) -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::std::os::raw::c_int, hasoid: bool_,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool_;
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::std::os::raw::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::std::os::raw::c_int);
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid);
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
    pub fn add_reloption_kind() -> relopt_kind;
    pub fn add_bool_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: bool_);
    pub fn add_int_reloption(kinds: bits32, name: *mut ::std::os::raw::c_char,
                             desc: *mut ::std::os::raw::c_char,
                             default_val: ::std::os::raw::c_int,
                             min_val: ::std::os::raw::c_int,
                             max_val: ::std::os::raw::c_int);
    pub fn add_real_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: f64, min_val: f64, max_val: f64);
    pub fn add_string_reloption(kinds: bits32,
                                name: *mut ::std::os::raw::c_char,
                                desc: *mut ::std::os::raw::c_char,
                                default_val: *mut ::std::os::raw::c_char,
                                validator: validate_string_relopt);
    pub fn transformRelOptions(oldOptions: Datum, defList: *mut List,
                               namspace: *mut ::std::os::raw::c_char,
                               validnsps: *mut *mut ::std::os::raw::c_char,
                               ignoreOids: bool_, isReset: bool_) -> Datum;
    pub fn untransformRelOptions(options: Datum) -> *mut List;
    pub fn extractRelOptions(tuple: HeapTuple, tupdesc: TupleDesc,
                             amoptions: Oid) -> *mut bytea;
    pub fn parseRelOptions(options: Datum, validate: bool_, kind: relopt_kind,
                           numrelopts: *mut ::std::os::raw::c_int)
     -> *mut relopt_value;
    pub fn allocateReloptStruct(base: Size, options: *mut relopt_value,
                                numoptions: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn fillRelOptions(rdopts: *mut ::std::os::raw::c_void, basesize: Size,
                          options: *mut relopt_value,
                          numoptions: ::std::os::raw::c_int, validate: bool_,
                          elems: *const relopt_parse_elt,
                          nelems: ::std::os::raw::c_int);
    pub fn default_reloptions(reloptions: Datum, validate: bool_,
                              kind: relopt_kind) -> *mut bytea;
    pub fn heap_reloptions(relkind: ::std::os::raw::c_char, reloptions: Datum,
                           validate: bool_) -> *mut bytea;
    pub fn index_reloptions(amoptions: RegProcedure, reloptions: Datum,
                            validate: bool_) -> *mut bytea;
    pub fn attribute_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext);
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext);
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32,
                                  count: int32) -> *mut varlena;
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo,
                             str: *mut ::std::os::raw::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidInputFunctionCall(functionId: Oid,
                                str: *mut ::std::os::raw::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(filehandle: *mut ::std::os::raw::c_void,
                              funcname: *mut ::std::os::raw::c_char)
     -> *const Pg_finfo_record;
    pub fn clear_external_function_hash(filehandle:
                                            *mut ::std::os::raw::c_void);
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char)
     -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo,
                               argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr,
                                 argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::std::os::raw::c_int) -> bool_;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr,
                                    argnum: ::std::os::raw::c_int) -> bool_;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool_;
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> bool_;
    pub fn load_external_function(filename: *mut ::std::os::raw::c_char,
                                  funcname: *mut ::std::os::raw::c_char,
                                  signalNotFound: bool_,
                                  filehandle:
                                      *mut *mut ::std::os::raw::c_void)
     -> PGFunction;
    pub fn lookup_external_function(filehandle: *mut ::std::os::raw::c_void,
                                    funcname: *mut ::std::os::raw::c_char)
     -> PGFunction;
    pub fn load_file(filename: *const ::std::os::raw::c_char,
                     restricted: bool_);
    pub fn find_rendezvous_variable(varName: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_void;
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::std::os::raw::c_int;
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::std::os::raw::c_char;
    pub fn ScanKeyInit(entry: ScanKey, attributeNumber: AttrNumber,
                       strategy: StrategyNumber, procedure: RegProcedure,
                       argument: Datum);
    pub fn ScanKeyEntryInitialize(entry: ScanKey,
                                  flags: ::std::os::raw::c_int,
                                  attributeNumber: AttrNumber,
                                  strategy: StrategyNumber, subtype: Oid,
                                  collation: Oid, procedure: RegProcedure,
                                  argument: Datum);
    pub fn ScanKeyEntryInitializeWithInfo(entry: ScanKey,
                                          flags: ::std::os::raw::c_int,
                                          attributeNumber: AttrNumber,
                                          strategy: StrategyNumber,
                                          subtype: Oid, collation: Oid,
                                          finfo: *mut FmgrInfo,
                                          argument: Datum);
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long) -> *mut TIDBitmap;
    pub fn tbm_free(tbm: *mut TIDBitmap);
    pub fn tbm_add_tuples(tbm: *mut TIDBitmap, tids: ItemPointer,
                          ntids: ::std::os::raw::c_int, recheck: bool_);
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool_;
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
    pub fn LWLockAssign() -> LWLockId;
    pub fn LWLockAcquire(lockid: LWLockId, mode: LWLockMode);
    pub fn LWLockConditionalAcquire(lockid: LWLockId, mode: LWLockMode)
     -> bool_;
    pub fn LWLockAcquireOrWait(lockid: LWLockId, mode: LWLockMode) -> bool_;
    pub fn LWLockRelease(lockid: LWLockId);
    pub fn LWLockReleaseAll();
    pub fn LWLockHeldByMe(lockid: LWLockId) -> bool_;
    pub fn NumLWLocks() -> ::std::os::raw::c_int;
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks();
    pub fn RequestAddinLWLocks(n: ::std::os::raw::c_int);
    pub fn hash_create(tabname: *const ::std::os::raw::c_char,
                       nelem: ::std::os::raw::c_long, info: *mut HASHCTL,
                       flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB);
    pub fn hash_stats(where_: *const ::std::os::raw::c_char,
                      hashp: *mut HTAB);
    pub fn hash_search(hashp: *mut HTAB,
                       keyPtr: *const ::std::os::raw::c_void,
                       action: HASHACTION, foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
    pub fn get_hash_value(hashp: *mut HTAB,
                          keyPtr: *const ::std::os::raw::c_void) -> uint32;
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::std::os::raw::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::std::os::raw::c_void,
                                newKeyPtr: *const ::std::os::raw::c_void)
     -> bool_;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
    pub fn hash_freeze(hashp: *mut HTAB);
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long,
                              entrysize: Size) -> Size;
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL,
                                flags: ::std::os::raw::c_int) -> Size;
    pub fn AtEOXact_HashTables(isCommit: bool_);
    pub fn AtEOSubXact_HashTables(isCommit: bool_,
                                  nestDepth: ::std::os::raw::c_int);
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn oid_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_match(key1: *const ::std::os::raw::c_void,
                        key2: *const ::std::os::raw::c_void, keysize: Size)
     -> ::std::os::raw::c_int;
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
    pub fn InitShmemAllocation();
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> bool_;
    pub fn InitShmemIndex();
    pub fn ShmemInitHash(name: *const ::std::os::raw::c_char,
                         init_size: ::std::os::raw::c_long,
                         max_size: ::std::os::raw::c_long,
                         infoP: *mut HASHCTL,
                         hash_flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn ShmemInitStruct(name: *const ::std::os::raw::c_char, size: Size,
                           foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size);
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE);
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> bool_;
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> bool_;
    pub fn InitLocks();
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool_;
    pub fn LockAcquire(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_, dontWait: bool_)
     -> LockAcquireResult;
    pub fn LockAcquireExtended(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                               sessionLock: bool_, dontWait: bool_,
                               report_memory_error: bool_)
     -> LockAcquireResult;
    pub fn AbortStrongLockAcquire();
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_) -> bool_;
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool_);
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                   nlocks: ::std::os::raw::c_int);
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                    nlocks: ::std::os::raw::c_int);
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                          sessionLock: bool_) -> bool_;
    pub fn GetLockConflicts(locktag: *const LOCKTAG, lockmode: LOCKMODE)
     -> *mut VirtualTransactionId;
    pub fn AtPrepare_Locks();
    pub fn PostPrepare_Locks(xid: TransactionId);
    pub fn LockCheckConflicts(lockMethodTable: LockMethod, lockmode: LOCKMODE,
                              lock: *mut LOCK, proclock: *mut PROCLOCK,
                              proc_: *mut PGPROC) -> ::std::os::raw::c_int;
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK,
                     lockmode: LOCKMODE);
    pub fn GrantAwaitedLock();
    pub fn RemoveFromWaitQueue(proc_: *mut PGPROC, hashcode: uint32);
    pub fn LockShmemSize() -> Size;
    pub fn GetLockStatusData() -> *mut LockData;
    pub fn ReportLockTableError(report: bool_);
    pub fn GetRunningTransactionLocks(nlocks: *mut ::std::os::raw::c_int)
     -> *mut xl_standby_lock;
    pub fn GetLockmodeName(lockmethodid: LOCKMETHODID, mode: LOCKMODE)
     -> *const ::std::os::raw::c_char;
    pub fn lock_twophase_recover(xid: TransactionId, info: uint16,
                                 recdata: *mut ::std::os::raw::c_void,
                                 len: uint32);
    pub fn lock_twophase_postcommit(xid: TransactionId, info: uint16,
                                    recdata: *mut ::std::os::raw::c_void,
                                    len: uint32);
    pub fn lock_twophase_postabort(xid: TransactionId, info: uint16,
                                   recdata: *mut ::std::os::raw::c_void,
                                   len: uint32);
    pub fn lock_twophase_standby_recover(xid: TransactionId, info: uint16,
                                         recdata: *mut ::std::os::raw::c_void,
                                         len: uint32);
    pub fn DeadLockCheck(proc_: *mut PGPROC) -> DeadLockState;
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
    pub fn DeadLockReport();
    pub fn RememberSimpleDeadLock(proc1: *mut PGPROC, lockmode: LOCKMODE,
                                  lock: *mut LOCK, proc2: *mut PGPROC);
    pub fn InitDeadLockChecking();
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
    pub fn VirtualXactLockTableCleanup();
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool_) -> bool_;
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset);
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset)
     -> bool_;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> bool_;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_is_empty(a: *const Bitmapset) -> bool_;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation);
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttrBitmap(relation: Relation, keyAttrs: bool_)
     -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16);
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid);
    pub fn RelationInitIndexAccessInfo(relation: Relation);
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errtablecolname(rel: Relation,
                           colname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errtableconstraint(rel: Relation,
                              conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn RelationCacheInitialize();
    pub fn RelationCacheInitializePhase2();
    pub fn RelationCacheInitializePhase3();
    pub fn RelationBuildLocalRelation(relname: *const ::std::os::raw::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: bool_,
                                      mapped_relation: bool_,
                                      relpersistence: ::std::os::raw::c_char,
                                      relkind: ::std::os::raw::c_char)
     -> Relation;
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId);
    pub fn RelationForgetRelation(rid: Oid);
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
    pub fn RelationCacheInvalidate();
    pub fn RelationCloseSmgrByOid(relationId: Oid);
    pub fn AtEOXact_RelationCache(isCommit: bool_);
    pub fn AtEOSubXact_RelationCache(isCommit: bool_,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId);
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool_;
    pub fn RelationCacheInitFilePreInvalidate();
    pub fn RelationCacheInitFilePostInvalidate();
    pub fn RelationCacheInitFileRemove();
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
    pub fn index_insert(indexRelation: Relation, values: *mut Datum,
                        isnull: *mut bool_, heap_t_ctid: ItemPointer,
                        heapRelation: Relation, checkUnique: IndexUniqueCheck)
     -> bool_;
    pub fn index_beginscan(heapRelation: Relation, indexRelation: Relation,
                           snapshot: Snapshot, nkeys: ::std::os::raw::c_int,
                           norderbys: ::std::os::raw::c_int) -> IndexScanDesc;
    pub fn index_beginscan_bitmap(indexRelation: Relation, snapshot: Snapshot,
                                  nkeys: ::std::os::raw::c_int)
     -> IndexScanDesc;
    pub fn index_rescan(scan: IndexScanDesc, keys: ScanKey,
                        nkeys: ::std::os::raw::c_int, orderbys: ScanKey,
                        norderbys: ::std::os::raw::c_int);
    pub fn index_endscan(scan: IndexScanDesc);
    pub fn index_markpos(scan: IndexScanDesc);
    pub fn index_restrpos(scan: IndexScanDesc);
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection)
     -> ItemPointer;
    pub fn index_fetch_heap(scan: IndexScanDesc) -> HeapTuple;
    pub fn index_getnext(scan: IndexScanDesc, direction: ScanDirection)
     -> HeapTuple;
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap)
     -> int64;
    pub fn index_bulk_delete(info: *mut IndexVacuumInfo,
                             stats: *mut IndexBulkDeleteResult,
                             callback: IndexBulkDeleteCallback,
                             callback_state: *mut ::std::os::raw::c_void)
     -> *mut IndexBulkDeleteResult;
    pub fn index_vacuum_cleanup(info: *mut IndexVacuumInfo,
                                stats: *mut IndexBulkDeleteResult)
     -> *mut IndexBulkDeleteResult;
    pub fn index_can_return(indexRelation: Relation) -> bool_;
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber,
                           procnum: uint16) -> RegProcedure;
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber,
                             procnum: uint16) -> *mut FmgrInfo;
    pub fn RelationGetIndexScan(indexRelation: Relation,
                                nkeys: ::std::os::raw::c_int,
                                norderbys: ::std::os::raw::c_int)
     -> IndexScanDesc;
    pub fn IndexScanEnd(scan: IndexScanDesc);
    pub fn BuildIndexValueDescription(indexRelation: Relation,
                                      values: *mut Datum, isnull: *mut bool_)
     -> *mut ::std::os::raw::c_char;
    pub fn systable_beginscan(heapRelation: Relation, indexId: Oid,
                              indexOK: bool_, snapshot: Snapshot,
                              nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> SysScanDesc;
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple)
     -> bool_;
    pub fn systable_endscan(sysscan: SysScanDesc);
    pub fn systable_beginscan_ordered(heapRelation: Relation,
                                      indexRelation: Relation,
                                      snapshot: Snapshot,
                                      nkeys: ::std::os::raw::c_int,
                                      key: ScanKey) -> SysScanDesc;
    pub fn systable_getnext_ordered(sysscan: SysScanDesc,
                                    direction: ScanDirection) -> HeapTuple;
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
    pub fn fcntl(__fd: ::std::os::raw::c_int,
                 __cmd: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn open(__file: *const ::std::os::raw::c_char,
                __oflag: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn openat(__fd: ::std::os::raw::c_int,
                  __file: *const ::std::os::raw::c_char,
                  __oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t)
     -> ::std::os::raw::c_int;
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: off_t) -> ::std::os::raw::c_int;
    pub fn posix_fadvise(__fd: ::std::os::raw::c_int, __offset: off_t,
                         __len: off_t, __advise: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn posix_fallocate(__fd: ::std::os::raw::c_int, __offset: off_t,
                           __len: off_t) -> ::std::os::raw::c_int;
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> bool_;
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: bool_,
                       is_heap: bool_) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
    pub fn PageRepairFragmentation(page: Page);
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::std::os::raw::c_int);
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
    pub fn relation_openrv_extended(relation: *const RangeVar,
                                    lockmode: LOCKMODE, missing_ok: bool_)
     -> Relation;
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
    pub fn heap_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn heap_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
    pub fn heap_openrv_extended(relation: *const RangeVar, lockmode: LOCKMODE,
                                missing_ok: bool_) -> Relation;
    pub fn heap_beginscan(relation: Relation, snapshot: Snapshot,
                          nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
    pub fn heap_beginscan_strat(relation: Relation, snapshot: Snapshot,
                                nkeys: ::std::os::raw::c_int, key: ScanKey,
                                allow_strat: bool_, allow_sync: bool_)
     -> HeapScanDesc;
    pub fn heap_beginscan_bm(relation: Relation, snapshot: Snapshot,
                             nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
    pub fn heap_rescan(scan: HeapScanDesc, key: ScanKey);
    pub fn heap_endscan(scan: HeapScanDesc);
    pub fn heap_getnext(scan: HeapScanDesc, direction: ScanDirection)
     -> HeapTuple;
    pub fn heap_fetch(relation: Relation, snapshot: Snapshot,
                      tuple: HeapTuple, userbuf: *mut Buffer, keep_buf: bool_,
                      stats_relation: Relation) -> bool_;
    pub fn heap_hot_search_buffer(tid: ItemPointer, relation: Relation,
                                  buffer: Buffer, snapshot: Snapshot,
                                  heapTuple: HeapTuple, all_dead: *mut bool_,
                                  first_call: bool_) -> bool_;
    pub fn heap_hot_search(tid: ItemPointer, relation: Relation,
                           snapshot: Snapshot, all_dead: *mut bool_) -> bool_;
    pub fn heap_get_latest_tid(relation: Relation, snapshot: Snapshot,
                               tid: ItemPointer);
    pub fn setLastTid(tid: ItemPointer);
    pub fn GetBulkInsertState() -> BulkInsertState;
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
    pub fn heap_insert(relation: Relation, tup: HeapTuple, cid: CommandId,
                       options: ::std::os::raw::c_int,
                       bistate: BulkInsertState) -> Oid;
    pub fn heap_multi_insert(relation: Relation, tuples: *mut HeapTuple,
                             ntuples: ::std::os::raw::c_int, cid: CommandId,
                             options: ::std::os::raw::c_int,
                             bistate: BulkInsertState);
    pub fn heap_delete(relation: Relation, tid: ItemPointer, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
    pub fn heap_update(relation: Relation, otid: ItemPointer,
                       newtup: HeapTuple, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData,
                       lockmode: *mut LockTupleMode) -> HTSU_Result;
    pub fn heap_lock_tuple(relation: Relation, tuple: HeapTuple,
                           cid: CommandId, mode: LockTupleMode, nowait: bool_,
                           follow_update: bool_, buffer: *mut Buffer,
                           hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
    pub fn heap_freeze_tuple(tuple: HeapTupleHeader,
                             cutoff_xid: TransactionId,
                             cutoff_multi: TransactionId) -> bool_;
    pub fn heap_tuple_needs_freeze(tuple: HeapTupleHeader,
                                   cutoff_xid: TransactionId,
                                   cutoff_multi: MultiXactId, buf: Buffer)
     -> bool_;
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple) -> Oid;
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
    pub fn simple_heap_update(relation: Relation, otid: ItemPointer,
                              tup: HeapTuple);
    pub fn heap_markpos(scan: HeapScanDesc);
    pub fn heap_restrpos(scan: HeapScanDesc);
    pub fn heap_sync(relation: Relation);
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer,
                               OldestXmin: TransactionId);
    pub fn heap_page_prune(relation: Relation, buffer: Buffer,
                           OldestXmin: TransactionId, report_stats: bool_,
                           latestRemovedXid: *mut TransactionId)
     -> ::std::os::raw::c_int;
    pub fn heap_page_prune_execute(buffer: Buffer,
                                   redirected: *mut OffsetNumber,
                                   nredirected: ::std::os::raw::c_int,
                                   nowdead: *mut OffsetNumber,
                                   ndead: ::std::os::raw::c_int,
                                   nowunused: *mut OffsetNumber,
                                   nunused: ::std::os::raw::c_int);
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
    pub fn ss_report_location(rel: Relation, location: BlockNumber);
    pub fn ss_get_location(rel: Relation, relnblocks: BlockNumber)
     -> BlockNumber;
    pub fn SyncScanShmemInit();
    pub fn SyncScanShmemSize() -> Size;
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> ::std::os::raw::c_int;
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> ::std::os::raw::c_int;
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> ::std::os::raw::c_int;
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> ::std::os::raw::c_int;
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> ::std::os::raw::c_int;
    pub fn utimes(__file: *const ::std::os::raw::c_char, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
    pub fn lutimes(__file: *const ::std::os::raw::c_char, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
    pub fn InstrAlloc(n: ::std::os::raw::c_int,
                      instrument_options: ::std::os::raw::c_int)
     -> *mut Instrumentation;
    pub fn InstrStartNode(instr: *mut Instrumentation);
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
    pub fn InstrEndLoop(instr: *mut Instrumentation);
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid,
                                            ssup: SortSupport);
    pub fn MakeTupleTableSlot() -> *mut TupleTableSlot;
    pub fn ExecAllocTableSlot(tupleTable: *mut *mut List)
     -> *mut TupleTableSlot;
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool_);
    pub fn MakeSingleTupleTableSlot(tupdesc: TupleDesc)
     -> *mut TupleTableSlot;
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot,
                                 tupdesc: TupleDesc);
    pub fn ExecStoreTuple(tuple: HeapTuple, slot: *mut TupleTableSlot,
                          buffer: Buffer, shouldFree: bool_)
     -> *mut TupleTableSlot;
    pub fn ExecStoreMinimalTuple(mtup: MinimalTuple,
                                 slot: *mut TupleTableSlot, shouldFree: bool_)
     -> *mut TupleTableSlot;
    pub fn ExecClearTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
    pub fn ExecCopySlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
    pub fn ExecCopySlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
    pub fn ExecFetchSlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
    pub fn ExecFetchSlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
    pub fn ExecFetchSlotTupleDatum(slot: *mut TupleTableSlot) -> Datum;
    pub fn ExecMaterializeSlot(slot: *mut TupleTableSlot) -> HeapTuple;
    pub fn ExecCopySlot(dstslot: *mut TupleTableSlot,
                        srcslot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn slot_getattr(slot: *mut TupleTableSlot,
                        attnum: ::std::os::raw::c_int, isnull: *mut bool_)
     -> Datum;
    pub fn slot_getallattrs(slot: *mut TupleTableSlot);
    pub fn slot_getsomeattrs(slot: *mut TupleTableSlot,
                             attnum: ::std::os::raw::c_int);
    pub fn slot_attisnull(slot: *mut TupleTableSlot,
                          attnum: ::std::os::raw::c_int) -> bool_;
    pub fn tuplestore_begin_heap(randomAccess: bool_, interXact: bool_,
                                 maxKBytes: ::std::os::raw::c_int)
     -> *mut Tuplestorestate;
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate,
                                 eflags: ::std::os::raw::c_int);
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate,
                                   slot: *mut TupleTableSlot);
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
    pub fn tuplestore_putvalues(state: *mut Tuplestorestate, tdesc: TupleDesc,
                                values: *mut Datum, isnull: *mut bool_);
    pub fn tuplestore_alloc_read_pointer(state: *mut Tuplestorestate,
                                         eflags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate,
                                          ptr: ::std::os::raw::c_int);
    pub fn tuplestore_copy_read_pointer(state: *mut Tuplestorestate,
                                        srcptr: ::std::os::raw::c_int,
                                        destptr: ::std::os::raw::c_int);
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool_;
    pub fn tuplestore_gettupleslot(state: *mut Tuplestorestate,
                                   forward: bool_, copy: bool_,
                                   slot: *mut TupleTableSlot) -> bool_;
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool_)
     -> bool_;
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool_;
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
    pub fn tuplestore_end(state: *mut Tuplestorestate);
    pub fn makeInteger(i: ::std::os::raw::c_long) -> *mut Value;
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn GetFdwRoutine(fdwhandler: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineByRelId(relid: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineForRelation(relation: Relation, makecopy: bool_)
     -> *mut FdwRoutine;
    pub fn GetForeignServer(serverid: Oid) -> *mut ForeignServer;
    pub fn GetForeignServerByName(name: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> *mut ForeignServer;
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> *mut UserMapping;
    pub fn GetForeignDataWrapper(fdwid: Oid) -> *mut ForeignDataWrapper;
    pub fn GetForeignDataWrapperByName(name: *const ::std::os::raw::c_char,
                                       missing_ok: bool_)
     -> *mut ForeignDataWrapper;
    pub fn GetForeignTable(relid: Oid) -> *mut ForeignTable;
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber)
     -> *mut List;
    pub fn get_foreign_data_wrapper_oid(fdwname:
                                            *const ::std::os::raw::c_char,
                                        missing_ok: bool_) -> Oid;
    pub fn get_foreign_server_oid(servername: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> Oid;
    pub fn compare_path_costs(path1: *mut Path, path2: *mut Path,
                              criterion: CostSelector)
     -> ::std::os::raw::c_int;
    pub fn compare_fractional_path_costs(path1: *mut Path, path2: *mut Path,
                                         fraction: f64)
     -> ::std::os::raw::c_int;
    pub fn set_cheapest(parent_rel: *mut RelOptInfo);
    pub fn add_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
    pub fn add_path_precheck(parent_rel: *mut RelOptInfo, startup_cost: Cost,
                             total_cost: Cost, pathkeys: *mut List,
                             required_outer: Relids) -> bool_;
    pub fn create_seqscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids) -> *mut Path;
    pub fn create_index_path(root: *mut PlannerInfo, index: *mut IndexOptInfo,
                             indexclauses: *mut List,
                             indexclausecols: *mut List,
                             indexorderbys: *mut List,
                             indexorderbycols: *mut List, pathkeys: *mut List,
                             indexscandir: ScanDirection, indexonly: bool_,
                             required_outer: Relids, loop_count: f64)
     -> *mut IndexPath;
    pub fn create_bitmap_heap_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo,
                                   bitmapqual: *mut Path,
                                   required_outer: Relids, loop_count: f64)
     -> *mut BitmapHeapPath;
    pub fn create_bitmap_and_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  bitmapquals: *mut List)
     -> *mut BitmapAndPath;
    pub fn create_bitmap_or_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 bitmapquals: *mut List) -> *mut BitmapOrPath;
    pub fn create_tidscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               tidquals: *mut List, required_outer: Relids)
     -> *mut TidPath;
    pub fn create_append_path(rel: *mut RelOptInfo, subpaths: *mut List,
                              required_outer: Relids) -> *mut AppendPath;
    pub fn create_merge_append_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpaths: *mut List,
                                    pathkeys: *mut List,
                                    required_outer: Relids)
     -> *mut MergeAppendPath;
    pub fn create_result_path(quals: *mut List) -> *mut ResultPath;
    pub fn create_material_path(rel: *mut RelOptInfo, subpath: *mut Path)
     -> *mut MaterialPath;
    pub fn create_unique_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              subpath: *mut Path,
                              sjinfo: *mut SpecialJoinInfo)
     -> *mut UniquePath;
    pub fn create_subqueryscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, pathkeys: *mut List,
                                    required_outer: Relids) -> *mut Path;
    pub fn create_functionscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo,
                                    required_outer: Relids) -> *mut Path;
    pub fn create_valuesscan_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  required_outer: Relids) -> *mut Path;
    pub fn create_ctescan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids) -> *mut Path;
    pub fn create_worktablescan_path(root: *mut PlannerInfo,
                                     rel: *mut RelOptInfo,
                                     required_outer: Relids) -> *mut Path;
    pub fn create_foreignscan_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo, rows: f64,
                                   startup_cost: Cost, total_cost: Cost,
                                   pathkeys: *mut List,
                                   required_outer: Relids,
                                   fdw_private: *mut List)
     -> *mut ForeignPath;
    pub fn calc_nestloop_required_outer(outer_path: *mut Path,
                                        inner_path: *mut Path) -> Relids;
    pub fn calc_non_nestloop_required_outer(outer_path: *mut Path,
                                            inner_path: *mut Path) -> Relids;
    pub fn create_nestloop_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                sjinfo: *mut SpecialJoinInfo,
                                semifactors: *mut SemiAntiJoinFactors,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                pathkeys: *mut List, required_outer: Relids)
     -> *mut NestPath;
    pub fn create_mergejoin_path(root: *mut PlannerInfo,
                                 joinrel: *mut RelOptInfo, jointype: JoinType,
                                 workspace: *mut JoinCostWorkspace,
                                 sjinfo: *mut SpecialJoinInfo,
                                 outer_path: *mut Path, inner_path: *mut Path,
                                 restrict_clauses: *mut List,
                                 pathkeys: *mut List, required_outer: Relids,
                                 mergeclauses: *mut List,
                                 outersortkeys: *mut List,
                                 innersortkeys: *mut List) -> *mut MergePath;
    pub fn create_hashjoin_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                sjinfo: *mut SpecialJoinInfo,
                                semifactors: *mut SemiAntiJoinFactors,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                required_outer: Relids,
                                hashclauses: *mut List) -> *mut HashPath;
    pub fn reparameterize_path(root: *mut PlannerInfo, path: *mut Path,
                               required_outer: Relids, loop_count: f64)
     -> *mut Path;
    pub fn setup_simple_rel_arrays(root: *mut PlannerInfo);
    pub fn build_simple_rel(root: *mut PlannerInfo,
                            relid: ::std::os::raw::c_int,
                            reloptkind: RelOptKind) -> *mut RelOptInfo;
    pub fn find_base_rel(root: *mut PlannerInfo, relid: ::std::os::raw::c_int)
     -> *mut RelOptInfo;
    pub fn find_join_rel(root: *mut PlannerInfo, relids: Relids)
     -> *mut RelOptInfo;
    pub fn build_join_rel(root: *mut PlannerInfo, joinrelids: Relids,
                          outer_rel: *mut RelOptInfo,
                          inner_rel: *mut RelOptInfo,
                          sjinfo: *mut SpecialJoinInfo,
                          restrictlist_ptr: *mut *mut List)
     -> *mut RelOptInfo;
    pub fn min_join_parameterization(root: *mut PlannerInfo,
                                     joinrelids: Relids,
                                     outer_rel: *mut RelOptInfo,
                                     inner_rel: *mut RelOptInfo) -> Relids;
    pub fn find_childrel_appendrelinfo(root: *mut PlannerInfo,
                                       rel: *mut RelOptInfo)
     -> *mut AppendRelInfo;
    pub fn find_childrel_top_parent(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo) -> *mut RelOptInfo;
    pub fn find_childrel_parents(root: *mut PlannerInfo, rel: *mut RelOptInfo)
     -> Relids;
    pub fn get_baserel_parampathinfo(root: *mut PlannerInfo,
                                     baserel: *mut RelOptInfo,
                                     required_outer: Relids)
     -> *mut ParamPathInfo;
    pub fn get_joinrel_parampathinfo(root: *mut PlannerInfo,
                                     joinrel: *mut RelOptInfo,
                                     outer_path: *mut Path,
                                     inner_path: *mut Path,
                                     sjinfo: *mut SpecialJoinInfo,
                                     required_outer: Relids,
                                     restrict_clauses: *mut *mut List)
     -> *mut ParamPathInfo;
    pub fn get_appendrel_parampathinfo(appendrel: *mut RelOptInfo,
                                       required_outer: Relids)
     -> *mut ParamPathInfo;
    pub fn query_planner(root: *mut PlannerInfo, tlist: *mut List,
                         tuple_fraction: f64, limit_tuples: f64,
                         qp_callback: query_pathkeys_callback,
                         qp_extra: *mut ::std::os::raw::c_void,
                         cheapest_path: *mut *mut Path,
                         sorted_path: *mut *mut Path, num_groups: *mut f64);
    pub fn preprocess_minmax_aggregates(root: *mut PlannerInfo,
                                        tlist: *mut List);
    pub fn optimize_minmax_aggregates(root: *mut PlannerInfo,
                                      tlist: *mut List,
                                      aggcosts: *const AggClauseCosts,
                                      best_path: *mut Path) -> *mut Plan;
    pub fn create_plan(root: *mut PlannerInfo, best_path: *mut Path)
     -> *mut Plan;
    pub fn make_subqueryscan(qptlist: *mut List, qpqual: *mut List,
                             scanrelid: Index, subplan: *mut Plan)
     -> *mut SubqueryScan;
    pub fn make_foreignscan(qptlist: *mut List, qpqual: *mut List,
                            scanrelid: Index, fdw_exprs: *mut List,
                            fdw_private: *mut List) -> *mut ForeignScan;
    pub fn make_append(appendplans: *mut List, tlist: *mut List)
     -> *mut Append;
    pub fn make_recursive_union(tlist: *mut List, lefttree: *mut Plan,
                                righttree: *mut Plan,
                                wtParam: ::std::os::raw::c_int,
                                distinctList: *mut List,
                                numGroups: ::std::os::raw::c_long)
     -> *mut RecursiveUnion;
    pub fn make_sort_from_pathkeys(root: *mut PlannerInfo,
                                   lefttree: *mut Plan, pathkeys: *mut List,
                                   limit_tuples: f64) -> *mut Sort;
    pub fn make_sort_from_sortclauses(root: *mut PlannerInfo,
                                      sortcls: *mut List, lefttree: *mut Plan)
     -> *mut Sort;
    pub fn make_sort_from_groupcols(root: *mut PlannerInfo,
                                    groupcls: *mut List,
                                    grpColIdx: *mut AttrNumber,
                                    lefttree: *mut Plan) -> *mut Sort;
    pub fn make_agg(root: *mut PlannerInfo, tlist: *mut List, qual: *mut List,
                    aggstrategy: AggStrategy, aggcosts: *const AggClauseCosts,
                    numGroupCols: ::std::os::raw::c_int,
                    grpColIdx: *mut AttrNumber, grpOperators: *mut Oid,
                    numGroups: ::std::os::raw::c_long, lefttree: *mut Plan)
     -> *mut Agg;
    pub fn make_windowagg(root: *mut PlannerInfo, tlist: *mut List,
                          windowFuncs: *mut List, winref: Index,
                          partNumCols: ::std::os::raw::c_int,
                          partColIdx: *mut AttrNumber,
                          partOperators: *mut Oid,
                          ordNumCols: ::std::os::raw::c_int,
                          ordColIdx: *mut AttrNumber, ordOperators: *mut Oid,
                          frameOptions: ::std::os::raw::c_int,
                          startOffset: *mut Node, endOffset: *mut Node,
                          lefttree: *mut Plan) -> *mut WindowAgg;
    pub fn make_group(root: *mut PlannerInfo, tlist: *mut List,
                      qual: *mut List, numGroupCols: ::std::os::raw::c_int,
                      grpColIdx: *mut AttrNumber, grpOperators: *mut Oid,
                      numGroups: f64, lefttree: *mut Plan) -> *mut Group;
    pub fn materialize_finished_plan(subplan: *mut Plan) -> *mut Plan;
    pub fn make_unique(lefttree: *mut Plan, distinctList: *mut List)
     -> *mut Unique;
    pub fn make_lockrows(lefttree: *mut Plan, rowMarks: *mut List,
                         epqParam: ::std::os::raw::c_int) -> *mut LockRows;
    pub fn make_limit(lefttree: *mut Plan, limitOffset: *mut Node,
                      limitCount: *mut Node, offset_est: int64,
                      count_est: int64) -> *mut Limit;
    pub fn make_setop(cmd: SetOpCmd, strategy: SetOpStrategy,
                      lefttree: *mut Plan, distinctList: *mut List,
                      flagColIdx: AttrNumber,
                      firstFlag: ::std::os::raw::c_int,
                      numGroups: ::std::os::raw::c_long, outputRows: f64)
     -> *mut SetOp;
    pub fn make_result(root: *mut PlannerInfo, tlist: *mut List,
                       resconstantqual: *mut Node, subplan: *mut Plan)
     -> *mut Result;
    pub fn make_modifytable(root: *mut PlannerInfo, operation: CmdType,
                            canSetTag: bool_, resultRelations: *mut List,
                            subplans: *mut List, returningLists: *mut List,
                            rowMarks: *mut List,
                            epqParam: ::std::os::raw::c_int)
     -> *mut ModifyTable;
    pub fn is_projection_capable_plan(plan: *mut Plan) -> bool_;
    pub fn add_base_rels_to_query(root: *mut PlannerInfo, jtnode: *mut Node);
    pub fn build_base_rel_tlists(root: *mut PlannerInfo,
                                 final_tlist: *mut List);
    pub fn add_vars_to_targetlist(root: *mut PlannerInfo, vars: *mut List,
                                  where_needed: Relids, create_new_ph: bool_);
    pub fn find_lateral_references(root: *mut PlannerInfo);
    pub fn create_lateral_join_info(root: *mut PlannerInfo);
    pub fn deconstruct_jointree(root: *mut PlannerInfo) -> *mut List;
    pub fn distribute_restrictinfo_to_rels(root: *mut PlannerInfo,
                                           restrictinfo: *mut RestrictInfo);
    pub fn process_implied_equality(root: *mut PlannerInfo, opno: Oid,
                                    collation: Oid, item1: *mut Expr,
                                    item2: *mut Expr, qualscope: Relids,
                                    nullable_relids: Relids,
                                    below_outer_join: bool_,
                                    both_const: bool_);
    pub fn build_implied_join_equality(opno: Oid, collation: Oid,
                                       item1: *mut Expr, item2: *mut Expr,
                                       qualscope: Relids,
                                       nullable_relids: Relids)
     -> *mut RestrictInfo;
    pub fn remove_useless_joins(root: *mut PlannerInfo, joinlist: *mut List)
     -> *mut List;
    pub fn set_plan_references(root: *mut PlannerInfo, plan: *mut Plan)
     -> *mut Plan;
    pub fn fix_opfuncids(node: *mut Node);
    pub fn set_opfuncid(opexpr: *mut OpExpr);
    pub fn set_sa_opfuncid(opexpr: *mut ScalarArrayOpExpr);
    pub fn record_plan_function_dependency(root: *mut PlannerInfo,
                                           funcid: Oid);
    pub fn extract_query_dependencies(query: *mut Node,
                                      relationOids: *mut *mut List,
                                      invalItems: *mut *mut List);
    pub fn make_restrictinfo(clause: *mut Expr, is_pushed_down: bool_,
                             outerjoin_delayed: bool_, pseudoconstant: bool_,
                             required_relids: Relids, outer_relids: Relids,
                             nullable_relids: Relids) -> *mut RestrictInfo;
    pub fn make_restrictinfo_from_bitmapqual(bitmapqual: *mut Path,
                                             is_pushed_down: bool_,
                                             include_predicates: bool_)
     -> *mut List;
    pub fn make_restrictinfos_from_actual_clauses(root: *mut PlannerInfo,
                                                  clause_list: *mut List)
     -> *mut List;
    pub fn restriction_is_or_clause(restrictinfo: *mut RestrictInfo) -> bool_;
    pub fn get_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
    pub fn get_all_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
    pub fn extract_actual_clauses(restrictinfo_list: *mut List,
                                  pseudoconstant: bool_) -> *mut List;
    pub fn extract_actual_join_clauses(restrictinfo_list: *mut List,
                                       joinquals: *mut *mut List,
                                       otherquals: *mut *mut List);
    pub fn join_clause_is_movable_to(rinfo: *mut RestrictInfo,
                                     baserel: *mut RelOptInfo) -> bool_;
    pub fn join_clause_is_movable_into(rinfo: *mut RestrictInfo,
                                       currentrelids: Relids,
                                       current_and_outer: Relids) -> bool_;
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::std::os::raw::c_char,
                      result: *mut bool_) -> bool_;
    pub fn parse_bool_with_len(value: *const ::std::os::raw::c_char,
                               len: size_t, result: *mut bool_) -> bool_;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_check(value: Datum, isnull: bool_, domainType: Oid,
                        extra: *mut *mut ::std::os::raw::c_void,
                        mcxt: MemoryContext);
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hex_encode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn hex_decode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int)
     -> *mut int2vector;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_atoi(s: *mut ::std::os::raw::c_char,
                   size: ::std::os::raw::c_int, c: ::std::os::raw::c_int)
     -> int32;
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_float8_infinity() -> f64;
    pub fn get_float4_infinity() -> f32;
    pub fn get_float8_nan() -> f64;
    pub fn get_float4_nan() -> f32;
    pub fn is_infinite(val: f64) -> ::std::os::raw::c_int;
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::std::os::raw::c_int;
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::std::os::raw::c_int;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn read_binary_file(filename: *const ::std::os::raw::c_char,
                            seek_offset: int64, bytes_to_read: int64)
     -> *mut bytea;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int)
     -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: bool_,
                               collation: Oid, exact: *mut bool_)
     -> *mut ::std::os::raw::c_char;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn stringToQualifiedNameList(string: *const ::std::os::raw::c_char)
     -> *mut List;
    pub fn format_procedure(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_procedure_qualified(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_operator(operator_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_operator_qualified(operator_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_string(indexrelid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_indexdef_columns(indexrelid: Oid, pretty: bool_)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_string(constraintId: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn deparse_expression(expr: *mut Node, dpcontext: *mut List,
                              forceprefix: bool_, showimplicit: bool_)
     -> *mut ::std::os::raw::c_char;
    pub fn deparse_context_for(aliasname: *const ::std::os::raw::c_char,
                               relid: Oid) -> *mut List;
    pub fn deparse_context_for_plan_rtable(rtable: *mut List,
                                           rtable_names: *mut List)
     -> *mut List;
    pub fn set_deparse_context_planstate(dpcontext: *mut List,
                                         planstate: *mut Node,
                                         ancestors: *mut List) -> *mut List;
    pub fn select_rtable_names_for_explain(rtable: *mut List,
                                           rels_used: *mut Bitmapset)
     -> *mut List;
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn quote_qualified_identifier(qualifier:
                                          *const ::std::os::raw::c_char,
                                      ident: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn generate_collation_name(collid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(s: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
    pub fn text_to_cstring_buffer(src: *const text,
                                  dst: *mut ::std::os::raw::c_char,
                                  dst_len: size_t);
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varstr_cmp(arg1: *mut ::std::os::raw::c_char,
                      len1: ::std::os::raw::c_int,
                      arg2: *mut ::std::os::raw::c_char,
                      len2: ::std::os::raw::c_int, collid: Oid)
     -> ::std::os::raw::c_int;
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
    pub fn SplitIdentifierString(rawstring: *mut ::std::os::raw::c_char,
                                 separator: ::std::os::raw::c_char,
                                 namelist: *mut *mut List) -> bool_;
    pub fn SplitDirectoriesString(rawstring: *mut ::std::os::raw::c_char,
                                  separator: ::std::os::raw::c_char,
                                  namelist: *mut *mut List) -> bool_;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text_regexp(src_text: *mut text,
                               regexp: *mut ::std::os::raw::c_void,
                               replace_text: *mut text, glob: bool_)
     -> *mut text;
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidComparator(arg1: *const ::std::os::raw::c_void,
                         arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_cidr_ntop(af: ::std::os::raw::c_int,
                          src: *const ::std::os::raw::c_void,
                          bits: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn inet_net_pton(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_char,
                         dst: *mut ::std::os::raw::c_void, size: size_t)
     -> ::std::os::raw::c_int;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid) -> f64;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_scan_first(in_: Datum) -> Datum;
    pub fn network_scan_last(in_: Datum) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int,
                           addr: *mut ::std::os::raw::c_char);
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_character_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_type_be_qualified(type_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str: StringInfo);
    pub fn resetStringInfo(str: StringInfo);
    pub fn appendStringInfo(str: StringInfo,
                            fmt: *const ::std::os::raw::c_char, ...);
    pub fn appendStringInfoVA(str: StringInfo,
                              fmt: *const ::std::os::raw::c_char,
                              args: va_list) -> bool_;
    pub fn appendStringInfoString(str: StringInfo,
                                  s: *const ::std::os::raw::c_char);
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
    pub fn appendStringInfoSpaces(str: StringInfo,
                                  count: ::std::os::raw::c_int);
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::std::os::raw::c_char,
                                  datalen: ::std::os::raw::c_int);
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn escape_json(buf: StringInfo, str: *const ::std::os::raw::c_char);
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool_;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::std::os::raw::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: bool_,
                                      strategy: *mut ::std::os::raw::c_int,
                                      lefttype: *mut Oid,
                                      righttype: *mut Oid);
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> bool_;
    pub fn get_sort_function_for_ordering_op(opno: Oid, sortfunc: *mut Oid,
                                             issupport: *mut bool_,
                                             reverse: *mut bool_) -> bool_;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut bool_)
     -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool_)
     -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> bool_;
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> bool_;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool_;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
    pub fn get_attname(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char)
     -> AttrNumber;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid);
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool_;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool_;
    pub fn op_strict(opno: Oid) -> bool_;
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::std::os::raw::c_int) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> bool_;
    pub fn func_strict(funcid: Oid) -> bool_;
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> bool_;
    pub fn get_func_cost(funcid: Oid) -> float4;
    pub fn get_func_rows(funcid: Oid) -> float4;
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char,
                             relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_typisdefined(typid: Oid) -> bool_;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> bool_;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut bool_);
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut bool_,
                                typalign: *mut ::std::os::raw::c_char);
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut bool_,
                            typalign: *mut ::std::os::raw::c_char,
                            typdelim: *mut ::std::os::raw::c_char,
                            typioparam: *mut Oid, func: *mut Oid);
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
    pub fn type_is_rowtype(typid: Oid) -> bool_;
    pub fn type_is_enum(typid: Oid) -> bool_;
    pub fn type_is_range(typid: Oid) -> bool_;
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory:
                                           *mut ::std::os::raw::c_char,
                                       typispreferred: *mut bool_);
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(type_: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid);
    pub fn getTypeOutputInfo(type_: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut bool_);
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid);
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut bool_);
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> bool_;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(statstuple: HeapTuple, atttype: Oid,
                            atttypmod: int32, reqkind: ::std::os::raw::c_int,
                            reqop: Oid, actualop: *mut Oid,
                            values: *mut *mut Datum,
                            nvalues: *mut ::std::os::raw::c_int,
                            numbers: *mut *mut float4,
                            nnumbers: *mut ::std::os::raw::c_int) -> bool_;
    pub fn free_attstatsslot(atttype: Oid, values: *mut Datum,
                             nvalues: ::std::os::raw::c_int,
                             numbers: *mut float4,
                             nnumbers: ::std::os::raw::c_int);
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn RelationIncrementReferenceCount(rel: Relation);
    pub fn RelationDecrementReferenceCount(rel: Relation);
}
