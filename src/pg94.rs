/* automatically generated by rust-bindgen */

pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed1 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __fsid_t = Struct_Unnamed1;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed2 {
    pub __count: ::std::os::raw::c_int,
    pub __value: Union_Unnamed3,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed3 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed3 {
    pub unsafe fn __wch(&mut self) -> *mut ::std::os::raw::c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Struct_Unnamed2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed4 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos_t = Struct_Unnamed4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed5 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos64_t = Struct_Unnamed5;
pub enum Struct__IO_jump_t { }
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct__IO_marker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum___codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct__IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl ::std::default::Default for Struct__IO_FILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _IO_FILE = Struct__IO_FILE;
pub enum Struct__IO_FILE_plus { }
pub type __io_read_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: size_t)
        -> __ssize_t;
pub type __io_write_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *const ::std::os::raw::c_char, __n: size_t)
        -> __ssize_t;
pub type __io_seek_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __pos: *mut __off64_t, __w: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type __io_close_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
pub type wchar_t = ::std::os::raw::c_int;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed6 { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type idtype_t = Enum_Unnamed6;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_terminated(&mut self) -> *mut Struct_Unnamed7 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_stopped(&mut self) -> *mut Struct_Unnamed8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed7 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed8 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed9 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed9 {
    pub unsafe fn __uptr(&mut self) -> *mut *mut Union_wait {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __iptr(&mut self) -> *mut *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __WAIT_STATUS = Union_Unnamed9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed10 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed11 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed12 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed12;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type _uint = ::std::os::raw::c_uint;
pub type int8_t = ::std::os::raw::c_char;
pub type int16_t = ::std::os::raw::c_short;
pub type int32_t = ::std::os::raw::c_int;
pub type int64_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed13 {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __sigset_t = Struct_Unnamed13;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed14 {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_Unnamed14;
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_pthread_attr_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_attr_t = Union_pthread_attr_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
impl ::std::default::Default for Struct___pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = Struct___pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed15 {
    pub _bindgen_data_: [u64; 5usize],
}
impl Union_Unnamed15 {
    pub unsafe fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for Struct___pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutex_t = Union_Unnamed15;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed16 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed16 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutexattr_t = Union_Unnamed16;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed17 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed18 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed18 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_cond_t = Union_Unnamed17;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed19 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed19 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_condattr_t = Union_Unnamed19;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed20 {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_Unnamed20 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed21 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed21 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlock_t = Union_Unnamed20;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed22 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed22 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlockattr_t = Union_Unnamed22;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed23 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed23 {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrier_t = Union_Unnamed23;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed24 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed24 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed24 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrierattr_t = Union_Unnamed24;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut int32_t,
}
impl ::std::default::Default for Struct_random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
impl ::std::default::Default for Struct_drand48_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub enum Struct___locale_data { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
impl ::std::default::Default for Struct___locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub type ptrdiff_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed25 {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __max_align_ld: ::std::os::raw::c_double,
}
impl ::std::default::Default for Struct_Unnamed25 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type max_align_t = Struct_Unnamed25;
pub type uint8_t = ::std::os::raw::c_uchar;
pub type uint16_t = ::std::os::raw::c_ushort;
pub type uint32_t = ::std::os::raw::c_uint;
pub type uint64_t = ::std::os::raw::c_ulong;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intptr_t = ::std::os::raw::c_long;
pub type uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_lconv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _bool = ::std::os::raw::c_char;
pub type BoolPtr = *mut _bool;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_char;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type Size = size_t;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = ::std::os::raw::c_float;
pub type float8 = ::std::os::raw::c_double;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed26 {
    pub indx: [::std::os::raw::c_int; 6usize],
}
impl ::std::default::Default for Struct_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntArray = Struct_Unnamed26;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_varlena {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bytea = Struct_varlena;
pub type text = Struct_varlena;
pub type BpChar = Struct_varlena;
pub type VarChar = Struct_varlena;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed27 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: [int16; 1usize],
}
impl ::std::default::Default for Struct_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int2vector = Struct_Unnamed27;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed28 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: [Oid; 1usize],
}
impl ::std::default::Default for Struct_Unnamed28 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type oidvector = Struct_Unnamed28;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_nameData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_nameData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NameData = Struct_nameData;
pub type Name = *mut NameData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed29 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
impl ::std::default::Default for Struct_iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type socklen_t = __socklen_t;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum___socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
impl ::std::default::Default for Struct_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_align: ::std::os::raw::c_ulong,
    pub __ss_padding: [::std::os::raw::c_char; 112usize],
}
impl ::std::clone::Clone for Struct_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed30 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: [::std::os::raw::c_uchar; 0usize],
}
impl ::std::default::Default for Struct_cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed31 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
impl ::std::default::Default for Struct_osockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed32 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
pub type in_addr_t = uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_in_addr {
    pub s_addr: in_addr_t,
}
impl ::std::default::Default for Struct_in_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_opts {
    pub ip_dst: Struct_in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
impl ::std::clone::Clone for Struct_ip_opts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ip_mreqn {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_address: Struct_in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ip_mreqn {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: Struct_in_addr,
    pub ipi_addr: Struct_in_addr,
}
impl ::std::default::Default for Struct_in_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed33 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed34 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = uint16_t;
pub const IPPORT_BIFFUDP: Enum_Unnamed35 = Enum_Unnamed35::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: Enum_Unnamed35 =
    Enum_Unnamed35::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: Enum_Unnamed35 =
    Enum_Unnamed35::IPPORT_EFSSERVER;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed35 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_in6_addr {
    pub __in6_u: Union_Unnamed36,
}
impl ::std::default::Default for Struct_in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed36 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed36 {
    pub unsafe fn __u6_addr8(&mut self) -> *mut [uint8_t; 16usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr16(&mut self) -> *mut [uint16_t; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr32(&mut self) -> *mut [uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: Struct_in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
impl ::std::default::Default for Struct_sockaddr_in {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: Struct_in6_addr,
    pub sin6_scope_id: uint32_t,
}
impl ::std::default::Default for Struct_sockaddr_in6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ip_mreq {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::default::Default for Struct_ip_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ip_mreq_source {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
    pub imr_sourceaddr: Struct_in_addr,
}
impl ::std::default::Default for Struct_ip_mreq_source {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ipv6_mreq {
    pub ipv6mr_multiaddr: Struct_in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_ipv6_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_req {
    pub gr_interface: uint32_t,
    pub gr_group: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: Struct_sockaddr_storage,
    pub gsr_source: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_source_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_source_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ip_msfilter {
    pub imsf_multiaddr: Struct_in_addr,
    pub imsf_interface: Struct_in_addr,
    pub imsf_fmode: uint32_t,
    pub imsf_numsrc: uint32_t,
    pub imsf_slist: [Struct_in_addr; 1usize],
}
impl ::std::default::Default for Struct_ip_msfilter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_filter {
    pub gf_interface: uint32_t,
    pub gf_group: Struct_sockaddr_storage,
    pub gf_fmode: uint32_t,
    pub gf_numsrc: uint32_t,
    pub gf_slist: [Struct_sockaddr_storage; 1usize],
}
impl ::std::clone::Clone for Struct_group_filter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_filter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_rpcent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: uint32_t,
}
impl ::std::default::Default for Struct_netent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_hostent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_servent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_protoent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut Struct_sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut Struct_addrinfo,
}
impl ::std::default::Default for Struct_addrinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_passwd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgsocket = ::std::os::raw::c_int;
pub type qsort_arg_comparator =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *const ::std::os::raw::c_void,
                                               b:
                                                   *const ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type pqsigfunc =
    ::std::option::Option<extern "C" fn(signo: ::std::os::raw::c_int)>;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct___jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
impl ::std::default::Default for Struct___jmp_buf_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type jmp_buf = [Struct___jmp_buf_tag; 1usize];
pub type sigjmp_buf = [Struct___jmp_buf_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ErrorContextCallback {
    pub previous: *mut Struct_ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for Struct_ErrorContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorContextCallback = Struct_ErrorContextCallback;
pub enum Struct_MemoryContextData { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: _bool,
    pub output_to_client: _bool,
    pub show_funcname: _bool,
    pub hide_stmt: _bool,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut Struct_MemoryContextData,
}
impl ::std::default::Default for Struct_ErrorData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorData = Struct_ErrorData;
pub type emit_log_hook_type =
    ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed37 {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
pub type PGErrorVerbosity = Enum_Unnamed37;
pub type MemoryContext = *mut Struct_MemoryContextData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl ::std::default::Default for Struct_varatt_external {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_external = Struct_varatt_external;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_varatt_indirect {
    pub pointer: *mut Struct_varlena,
}
impl ::std::default::Default for Struct_varatt_indirect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_indirect = Struct_varatt_indirect;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_vartag_external { VARTAG_INDIRECT = 1, VARTAG_ONDISK = 18, }
pub type vartag_external = Enum_vartag_external;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed38 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed38 {
    pub unsafe fn va_4byte(&mut self) -> *mut Struct_Unnamed39 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn va_compressed(&mut self) -> *mut Struct_Unnamed40 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed38 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed39 {
    pub va_header: uint32,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed39 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed40 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed40 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_4b = Union_Unnamed38;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed41 {
    pub va_header: uint8,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed41 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b = Struct_Unnamed41;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed42 {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: [::std::os::raw::c_char; 1usize],
}
impl ::std::default::Default for Struct_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b_e = Struct_Unnamed42;
pub type Datum = uintptr_t;
pub type DatumPtr = *mut Datum;
pub type fmNodePtr = *mut Struct_Node;
pub type fmAggrefPtr = *mut Struct_Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<extern "C" fn(arg: Datum)>;
pub type fmStringInfo = *mut Struct_StringInfoData;
pub type FunctionCallInfo = *mut Struct_FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: _bool,
    pub fn_retset: _bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl ::std::default::Default for Struct_FmgrInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FmgrInfo = Struct_FmgrInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: _bool,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [_bool; 100usize],
}
impl ::std::clone::Clone for Struct_FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionCallInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionCallInfoData = Struct_FunctionCallInfoData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed43 {
    pub api_version: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Unnamed43 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_finfo_record = Struct_Unnamed43;
pub type PGFInfoFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed44 {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_magic_struct = Struct_Unnamed44;
pub type PGModuleMagicFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_magic_struct>;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_FmgrHookEventType {
    FHET_START = 0,
    FHET_END = 1,
    FHET_ABORT = 2,
}
pub type FmgrHookEventType = Enum_FmgrHookEventType;
pub type needs_fmgr_hook_type =
    ::std::option::Option<extern "C" fn(fn_oid: Oid) -> _bool>;
pub type fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(event: FmgrHookEventType,
                                               flinfo: *mut FmgrInfo,
                                               arg: *mut Datum)>;
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: [bitmapword; 1usize],
}
impl ::std::default::Default for Struct_Bitmapset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Bitmapset = Struct_Bitmapset;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed45 {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
pub type BMS_Comparison = Enum_Unnamed45;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed46 {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
pub type BMS_Membership = Enum_Unnamed46;
pub type AttrNumber = int16;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 10,
    T_ExprContext = 11,
    T_ProjectionInfo = 12,
    T_JunkFilter = 13,
    T_ResultRelInfo = 14,
    T_EState = 15,
    T_TupleTableSlot = 16,
    T_Plan = 100,
    T_Result = 101,
    T_ModifyTable = 102,
    T_Append = 103,
    T_MergeAppend = 104,
    T_RecursiveUnion = 105,
    T_BitmapAnd = 106,
    T_BitmapOr = 107,
    T_Scan = 108,
    T_SeqScan = 109,
    T_IndexScan = 110,
    T_IndexOnlyScan = 111,
    T_BitmapIndexScan = 112,
    T_BitmapHeapScan = 113,
    T_TidScan = 114,
    T_SubqueryScan = 115,
    T_FunctionScan = 116,
    T_ValuesScan = 117,
    T_CteScan = 118,
    T_WorkTableScan = 119,
    T_ForeignScan = 120,
    T_Join = 121,
    T_NestLoop = 122,
    T_MergeJoin = 123,
    T_HashJoin = 124,
    T_Material = 125,
    T_Sort = 126,
    T_Group = 127,
    T_Agg = 128,
    T_WindowAgg = 129,
    T_Unique = 130,
    T_Hash = 131,
    T_SetOp = 132,
    T_LockRows = 133,
    T_Limit = 134,
    T_NestLoopParam = 135,
    T_PlanRowMark = 136,
    T_PlanInvalItem = 137,
    T_PlanState = 200,
    T_ResultState = 201,
    T_ModifyTableState = 202,
    T_AppendState = 203,
    T_MergeAppendState = 204,
    T_RecursiveUnionState = 205,
    T_BitmapAndState = 206,
    T_BitmapOrState = 207,
    T_ScanState = 208,
    T_SeqScanState = 209,
    T_IndexScanState = 210,
    T_IndexOnlyScanState = 211,
    T_BitmapIndexScanState = 212,
    T_BitmapHeapScanState = 213,
    T_TidScanState = 214,
    T_SubqueryScanState = 215,
    T_FunctionScanState = 216,
    T_ValuesScanState = 217,
    T_CteScanState = 218,
    T_WorkTableScanState = 219,
    T_ForeignScanState = 220,
    T_JoinState = 221,
    T_NestLoopState = 222,
    T_MergeJoinState = 223,
    T_HashJoinState = 224,
    T_MaterialState = 225,
    T_SortState = 226,
    T_GroupState = 227,
    T_AggState = 228,
    T_WindowAggState = 229,
    T_UniqueState = 230,
    T_HashState = 231,
    T_SetOpState = 232,
    T_LockRowsState = 233,
    T_LimitState = 234,
    T_Alias = 300,
    T_RangeVar = 301,
    T_Expr = 302,
    T_Var = 303,
    T_Const = 304,
    T_Param = 305,
    T_Aggref = 306,
    T_WindowFunc = 307,
    T_ArrayRef = 308,
    T_FuncExpr = 309,
    T_NamedArgExpr = 310,
    T_OpExpr = 311,
    T_DistinctExpr = 312,
    T_NullIfExpr = 313,
    T_ScalarArrayOpExpr = 314,
    T_BoolExpr = 315,
    T_SubLink = 316,
    T_SubPlan = 317,
    T_AlternativeSubPlan = 318,
    T_FieldSelect = 319,
    T_FieldStore = 320,
    T_RelabelType = 321,
    T_CoerceViaIO = 322,
    T_ArrayCoerceExpr = 323,
    T_ConvertRowtypeExpr = 324,
    T_CollateExpr = 325,
    T_CaseExpr = 326,
    T_CaseWhen = 327,
    T_CaseTestExpr = 328,
    T_ArrayExpr = 329,
    T_RowExpr = 330,
    T_RowCompareExpr = 331,
    T_CoalesceExpr = 332,
    T_MinMaxExpr = 333,
    T_XmlExpr = 334,
    T_NullTest = 335,
    T_BooleanTest = 336,
    T_CoerceToDomain = 337,
    T_CoerceToDomainValue = 338,
    T_SetToDefault = 339,
    T_CurrentOfExpr = 340,
    T_TargetEntry = 341,
    T_RangeTblRef = 342,
    T_JoinExpr = 343,
    T_FromExpr = 344,
    T_IntoClause = 345,
    T_ExprState = 400,
    T_GenericExprState = 401,
    T_WholeRowVarExprState = 402,
    T_AggrefExprState = 403,
    T_WindowFuncExprState = 404,
    T_ArrayRefExprState = 405,
    T_FuncExprState = 406,
    T_ScalarArrayOpExprState = 407,
    T_BoolExprState = 408,
    T_SubPlanState = 409,
    T_AlternativeSubPlanState = 410,
    T_FieldSelectState = 411,
    T_FieldStoreState = 412,
    T_CoerceViaIOState = 413,
    T_ArrayCoerceExprState = 414,
    T_ConvertRowtypeExprState = 415,
    T_CaseExprState = 416,
    T_CaseWhenState = 417,
    T_ArrayExprState = 418,
    T_RowExprState = 419,
    T_RowCompareExprState = 420,
    T_CoalesceExprState = 421,
    T_MinMaxExprState = 422,
    T_XmlExprState = 423,
    T_NullTestState = 424,
    T_CoerceToDomainState = 425,
    T_DomainConstraintState = 426,
    T_PlannerInfo = 500,
    T_PlannerGlobal = 501,
    T_RelOptInfo = 502,
    T_IndexOptInfo = 503,
    T_ParamPathInfo = 504,
    T_Path = 505,
    T_IndexPath = 506,
    T_BitmapHeapPath = 507,
    T_BitmapAndPath = 508,
    T_BitmapOrPath = 509,
    T_NestPath = 510,
    T_MergePath = 511,
    T_HashPath = 512,
    T_TidPath = 513,
    T_ForeignPath = 514,
    T_AppendPath = 515,
    T_MergeAppendPath = 516,
    T_ResultPath = 517,
    T_MaterialPath = 518,
    T_UniquePath = 519,
    T_EquivalenceClass = 520,
    T_EquivalenceMember = 521,
    T_PathKey = 522,
    T_RestrictInfo = 523,
    T_PlaceHolderVar = 524,
    T_SpecialJoinInfo = 525,
    T_LateralJoinInfo = 526,
    T_AppendRelInfo = 527,
    T_PlaceHolderInfo = 528,
    T_MinMaxAggInfo = 529,
    T_PlannerParamItem = 530,
    T_MemoryContext = 600,
    T_AllocSetContext = 601,
    T_Value = 650,
    T_Integer = 651,
    T_Float = 652,
    T_String = 653,
    T_BitString = 654,
    T_Null = 655,
    T_List = 656,
    T_IntList = 657,
    T_OidList = 658,
    T_Query = 700,
    T_PlannedStmt = 701,
    T_InsertStmt = 702,
    T_DeleteStmt = 703,
    T_UpdateStmt = 704,
    T_SelectStmt = 705,
    T_AlterTableStmt = 706,
    T_AlterTableCmd = 707,
    T_AlterDomainStmt = 708,
    T_SetOperationStmt = 709,
    T_GrantStmt = 710,
    T_GrantRoleStmt = 711,
    T_AlterDefaultPrivilegesStmt = 712,
    T_ClosePortalStmt = 713,
    T_ClusterStmt = 714,
    T_CopyStmt = 715,
    T_CreateStmt = 716,
    T_DefineStmt = 717,
    T_DropStmt = 718,
    T_TruncateStmt = 719,
    T_CommentStmt = 720,
    T_FetchStmt = 721,
    T_IndexStmt = 722,
    T_CreateFunctionStmt = 723,
    T_AlterFunctionStmt = 724,
    T_DoStmt = 725,
    T_RenameStmt = 726,
    T_RuleStmt = 727,
    T_NotifyStmt = 728,
    T_ListenStmt = 729,
    T_UnlistenStmt = 730,
    T_TransactionStmt = 731,
    T_ViewStmt = 732,
    T_LoadStmt = 733,
    T_CreateDomainStmt = 734,
    T_CreatedbStmt = 735,
    T_DropdbStmt = 736,
    T_VacuumStmt = 737,
    T_ExplainStmt = 738,
    T_CreateTableAsStmt = 739,
    T_CreateSeqStmt = 740,
    T_AlterSeqStmt = 741,
    T_VariableSetStmt = 742,
    T_VariableShowStmt = 743,
    T_DiscardStmt = 744,
    T_CreateTrigStmt = 745,
    T_CreatePLangStmt = 746,
    T_CreateRoleStmt = 747,
    T_AlterRoleStmt = 748,
    T_DropRoleStmt = 749,
    T_LockStmt = 750,
    T_ConstraintsSetStmt = 751,
    T_ReindexStmt = 752,
    T_CheckPointStmt = 753,
    T_CreateSchemaStmt = 754,
    T_AlterDatabaseStmt = 755,
    T_AlterDatabaseSetStmt = 756,
    T_AlterRoleSetStmt = 757,
    T_CreateConversionStmt = 758,
    T_CreateCastStmt = 759,
    T_CreateOpClassStmt = 760,
    T_CreateOpFamilyStmt = 761,
    T_AlterOpFamilyStmt = 762,
    T_PrepareStmt = 763,
    T_ExecuteStmt = 764,
    T_DeallocateStmt = 765,
    T_DeclareCursorStmt = 766,
    T_CreateTableSpaceStmt = 767,
    T_DropTableSpaceStmt = 768,
    T_AlterObjectSchemaStmt = 769,
    T_AlterOwnerStmt = 770,
    T_DropOwnedStmt = 771,
    T_ReassignOwnedStmt = 772,
    T_CompositeTypeStmt = 773,
    T_CreateEnumStmt = 774,
    T_CreateRangeStmt = 775,
    T_AlterEnumStmt = 776,
    T_AlterTSDictionaryStmt = 777,
    T_AlterTSConfigurationStmt = 778,
    T_CreateFdwStmt = 779,
    T_AlterFdwStmt = 780,
    T_CreateForeignServerStmt = 781,
    T_AlterForeignServerStmt = 782,
    T_CreateUserMappingStmt = 783,
    T_AlterUserMappingStmt = 784,
    T_DropUserMappingStmt = 785,
    T_AlterTableSpaceOptionsStmt = 786,
    T_AlterTableMoveAllStmt = 787,
    T_SecLabelStmt = 788,
    T_CreateForeignTableStmt = 789,
    T_CreateExtensionStmt = 790,
    T_AlterExtensionStmt = 791,
    T_AlterExtensionContentsStmt = 792,
    T_CreateEventTrigStmt = 793,
    T_AlterEventTrigStmt = 794,
    T_RefreshMatViewStmt = 795,
    T_ReplicaIdentityStmt = 796,
    T_AlterSystemStmt = 797,
    T_A_Expr = 900,
    T_ColumnRef = 901,
    T_ParamRef = 902,
    T_A_Const = 903,
    T_FuncCall = 904,
    T_A_Star = 905,
    T_A_Indices = 906,
    T_A_Indirection = 907,
    T_A_ArrayExpr = 908,
    T_ResTarget = 909,
    T_TypeCast = 910,
    T_CollateClause = 911,
    T_SortBy = 912,
    T_WindowDef = 913,
    T_RangeSubselect = 914,
    T_RangeFunction = 915,
    T_TypeName = 916,
    T_ColumnDef = 917,
    T_IndexElem = 918,
    T_Constraint = 919,
    T_DefElem = 920,
    T_RangeTblEntry = 921,
    T_RangeTblFunction = 922,
    T_WithCheckOption = 923,
    T_SortGroupClause = 924,
    T_WindowClause = 925,
    T_PrivGrantee = 926,
    T_FuncWithArgs = 927,
    T_AccessPriv = 928,
    T_CreateOpClassItem = 929,
    T_TableLikeClause = 930,
    T_FunctionParameter = 931,
    T_LockingClause = 932,
    T_RowMarkClause = 933,
    T_XmlSerialize = 934,
    T_WithClause = 935,
    T_CommonTableExpr = 936,
    T_IdentifySystemCmd = 937,
    T_BaseBackupCmd = 938,
    T_CreateReplicationSlotCmd = 939,
    T_DropReplicationSlotCmd = 940,
    T_StartReplicationCmd = 941,
    T_TimeLineHistoryCmd = 942,
    T_TriggerData = 950,
    T_EventTriggerData = 951,
    T_ReturnSetInfo = 952,
    T_WindowObjectData = 953,
    T_TIDBitmap = 954,
    T_InlineCodeBlock = 955,
    T_FdwRoutine = 956,
}
pub type NodeTag = Enum_NodeTag;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Node {
    pub _type: NodeTag,
}
impl ::std::default::Default for Struct_Node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Node = Struct_Node;
pub type Selectivity = ::std::os::raw::c_double;
pub type Cost = ::std::os::raw::c_double;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
pub type CmdType = Enum_CmdType;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
pub type JoinType = Enum_JoinType;
pub type ListCell = Struct_ListCell;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_List {
    pub _type: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
impl ::std::default::Default for Struct_List {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type List = Struct_List;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ListCell {
    pub data: Union_Unnamed47,
    pub next: *mut ListCell,
}
impl ::std::default::Default for Struct_ListCell {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed47 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed47 {
    pub unsafe fn ptr_value(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_value(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn oid_value(&mut self) -> *mut Oid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Alias {
    pub _type: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
impl ::std::default::Default for Struct_Alias {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Alias = Struct_Alias;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_InhOption { INH_NO = 0, INH_YES = 1, INH_DEFAULT = 2, }
pub type InhOption = Enum_InhOption;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
pub type OnCommitAction = Enum_OnCommitAction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeVar {
    pub _type: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inhOpt: InhOption,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_RangeVar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeVar = Struct_RangeVar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_IntoClause {
    pub _type: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: _bool,
}
impl ::std::default::Default for Struct_IntoClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntoClause = Struct_IntoClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Expr {
    pub _type: NodeTag,
}
impl ::std::default::Default for Struct_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Expr = Struct_Expr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Var {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Var = Struct_Var;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: _bool,
    pub constbyval: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Const = Struct_Const;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ParamKind {
    PARAM_EXTERN = 0,
    PARAM_EXEC = 1,
    PARAM_SUBLINK = 2,
}
pub type ParamKind = Enum_ParamKind;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Param = Struct_Param;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: _bool,
    pub aggvariadic: _bool,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_Aggref {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Aggref = Struct_Aggref;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: _bool,
    pub winagg: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_WindowFunc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowFunc = Struct_WindowFunc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl ::std::default::Default for Struct_ArrayRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayRef = Struct_ArrayRef;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
pub type CoercionContext = Enum_CoercionContext;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
pub type CoercionForm = Enum_CoercionForm;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: _bool,
    pub funcvariadic: _bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_FuncExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncExpr = Struct_FuncExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_NamedArgExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NamedArgExpr = Struct_NamedArgExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: _bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_OpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpExpr = Struct_OpExpr;
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: _bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ScalarArrayOpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ScalarArrayOpExpr = Struct_ScalarArrayOpExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_BoolExprType { AND_EXPR = 0, OR_EXPR = 1, NOT_EXPR = 2, }
pub type BoolExprType = Enum_BoolExprType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_BoolExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BoolExpr = Struct_BoolExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    ARRAY_SUBLINK = 5,
    CTE_SUBLINK = 6,
}
pub type SubLinkType = Enum_SubLinkType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_SubLink {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubLink = Struct_SubLink;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: _bool,
    pub unknownEqFalse: _bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl ::std::default::Default for Struct_SubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubPlan = Struct_SubPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl ::std::default::Default for Struct_AlternativeSubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlternativeSubPlan = Struct_AlternativeSubPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl ::std::default::Default for Struct_FieldSelect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldSelect = Struct_FieldSelect;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl ::std::default::Default for Struct_FieldStore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldStore = Struct_FieldStore;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_RelabelType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelabelType = Struct_RelabelType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CoerceViaIO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceViaIO = Struct_CoerceViaIO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: _bool,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ArrayCoerceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayCoerceExpr = Struct_ArrayCoerceExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ConvertRowtypeExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConvertRowtypeExpr = Struct_ConvertRowtypeExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CollateExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateExpr = Struct_CollateExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CaseExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseExpr = Struct_CaseExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CaseWhen {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseWhen = Struct_CaseWhen;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl ::std::default::Default for Struct_CaseTestExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseTestExpr = Struct_CaseTestExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayExpr = Struct_ArrayExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_RowExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowExpr = Struct_RowExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
pub type RowCompareType = Enum_RowCompareType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl ::std::default::Default for Struct_RowCompareExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowCompareExpr = Struct_RowCompareExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CoalesceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoalesceExpr = Struct_CoalesceExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_MinMaxOp { IS_GREATEST = 0, IS_LEAST = 1, }
pub type MinMaxOp = Enum_MinMaxOp;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_MinMaxExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MinMaxExpr = Struct_MinMaxExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
pub type XmlExprOp = Enum_XmlExprOp;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed48 { XMLOPTION_DOCUMENT = 0, XMLOPTION_CONTENT = 1, }
pub type XmlOptionType = Enum_Unnamed48;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub _type: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_XmlExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlExpr = Struct_XmlExpr;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_NullTestType { IS_NULL = 0, IS_NOT_NULL = 1, }
pub type NullTestType = Enum_NullTestType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: _bool,
}
impl ::std::default::Default for Struct_NullTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NullTest = Struct_NullTest;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
pub type BoolTestType = Enum_BoolTestType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
}
impl ::std::default::Default for Struct_BooleanTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BooleanTest = Struct_BooleanTest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CoerceToDomain {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomain = Struct_CoerceToDomain;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CoerceToDomainValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomainValue = Struct_CoerceToDomainValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_SetToDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetToDefault = Struct_SetToDefault;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CurrentOfExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CurrentOfExpr = Struct_CurrentOfExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: _bool,
}
impl ::std::default::Default for Struct_TargetEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TargetEntry = Struct_TargetEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeTblRef {
    pub _type: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_RangeTblRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblRef = Struct_RangeTblRef;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_JoinExpr {
    pub _type: NodeTag,
    pub jointype: JoinType,
    pub isNatural: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_JoinExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type JoinExpr = Struct_JoinExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FromExpr {
    pub _type: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl ::std::default::Default for Struct_FromExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FromExpr = Struct_FromExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Value {
    pub _type: NodeTag,
    pub val: Union_ValUnion,
}
impl ::std::default::Default for Struct_Value {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_ValUnion {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_ValUnion {
    pub unsafe fn ival(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut *mut ::std::os::raw::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_ValUnion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Value = Struct_Value;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
pub type QuerySource = Enum_QuerySource;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
pub type SortByDir = Enum_SortByDir;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type SortByNulls = Enum_SortByNulls;
pub type AclMode = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Query {
    pub _type: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: _bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: _bool,
    pub hasWindowFuncs: _bool,
    pub hasSubLinks: _bool,
    pub hasDistinctOn: _bool,
    pub hasRecursive: _bool,
    pub hasModifyingCTE: _bool,
    pub hasForUpdate: _bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub withCheckOptions: *mut List,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
}
impl ::std::default::Default for Struct_Query {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Query = Struct_Query;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TypeName {
    pub _type: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: _bool,
    pub pct_type: _bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_TypeName {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeName = Struct_TypeName;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ColumnRef {
    pub _type: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ColumnRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnRef = Struct_ColumnRef;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ParamRef {
    pub _type: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ParamRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ParamRef = Struct_ParamRef;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_AND = 1,
    AEXPR_OR = 2,
    AEXPR_NOT = 3,
    AEXPR_OP_ANY = 4,
    AEXPR_OP_ALL = 5,
    AEXPR_DISTINCT = 6,
    AEXPR_NULLIF = 7,
    AEXPR_OF = 8,
    AEXPR_IN = 9,
}
pub type A_Expr_Kind = Enum_A_Expr_Kind;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_Expr {
    pub _type: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_A_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Expr = Struct_A_Expr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_Const {
    pub _type: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_A_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Const = Struct_A_Const;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TypeCast {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_TypeCast {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeCast = Struct_TypeCast;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CollateClause {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_CollateClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateClause = Struct_CollateClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FuncCall {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: _bool,
    pub agg_star: _bool,
    pub agg_distinct: _bool,
    pub func_variadic: _bool,
    pub over: *mut Struct_WindowDef,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_FuncCall {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncCall = Struct_FuncCall;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_Star {
    pub _type: NodeTag,
}
impl ::std::default::Default for Struct_A_Star {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Star = Struct_A_Star;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_Indices {
    pub _type: NodeTag,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl ::std::default::Default for Struct_A_Indices {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indices = Struct_A_Indices;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_Indirection {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl ::std::default::Default for Struct_A_Indirection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indirection = Struct_A_Indirection;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_A_ArrayExpr {
    pub _type: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_A_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_ArrayExpr = Struct_A_ArrayExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ResTarget {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ResTarget {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ResTarget = Struct_ResTarget;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SortBy {
    pub _type: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_SortBy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortBy = Struct_SortBy;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_WindowDef {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_WindowDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowDef = Struct_WindowDef;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeSubselect {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl ::std::default::Default for Struct_RangeSubselect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeSubselect = Struct_RangeSubselect;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeFunction {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub ordinality: _bool,
    pub is_rowsfrom: _bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl ::std::default::Default for Struct_RangeFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeFunction = Struct_RangeFunction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ColumnDef {
    pub _type: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: _bool,
    pub is_not_null: _bool,
    pub is_from_type: _bool,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ColumnDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnDef = Struct_ColumnDef;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TableLikeClause {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
impl ::std::default::Default for Struct_TableLikeClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TableLikeClause = Struct_TableLikeClause;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_TableLikeOption {
    CREATE_TABLE_LIKE_DEFAULTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_INDEXES = 4,
    CREATE_TABLE_LIKE_STORAGE = 8,
    CREATE_TABLE_LIKE_COMMENTS = 16,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
pub type TableLikeOption = Enum_TableLikeOption;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_IndexElem {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl ::std::default::Default for Struct_IndexElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexElem = Struct_IndexElem;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
pub type DefElemAction = Enum_DefElemAction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DefElem {
    pub _type: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
}
impl ::std::default::Default for Struct_DefElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefElem = Struct_DefElem;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_LockClauseStrength {
    LCS_FORKEYSHARE = 0,
    LCS_FORSHARE = 1,
    LCS_FORNOKEYUPDATE = 2,
    LCS_FORUPDATE = 3,
}
pub type LockClauseStrength = Enum_LockClauseStrength;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LockingClause {
    pub _type: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub noWait: _bool,
}
impl ::std::default::Default for Struct_LockingClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockingClause = Struct_LockingClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XmlSerialize {
    pub _type: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_XmlSerialize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlSerialize = Struct_XmlSerialize;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_VALUES = 4,
    RTE_CTE = 5,
}
pub type RTEKind = Enum_RTEKind;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeTblEntry {
    pub _type: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub subquery: *mut Query,
    pub security_barrier: _bool,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: _bool,
    pub values_lists: *mut List,
    pub values_collations: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: _bool,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: _bool,
    pub inh: _bool,
    pub inFromCl: _bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub modifiedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
impl ::std::default::Default for Struct_RangeTblEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblEntry = Struct_RangeTblEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RangeTblFunction {
    pub _type: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl ::std::default::Default for Struct_RangeTblFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblFunction = Struct_RangeTblFunction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_WithCheckOption {
    pub _type: NodeTag,
    pub viewname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: _bool,
}
impl ::std::default::Default for Struct_WithCheckOption {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithCheckOption = Struct_WithCheckOption;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SortGroupClause {
    pub _type: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: _bool,
    pub hashable: _bool,
}
impl ::std::default::Default for Struct_SortGroupClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortGroupClause = Struct_SortGroupClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_WindowClause {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: _bool,
}
impl ::std::default::Default for Struct_WindowClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowClause = Struct_WindowClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RowMarkClause {
    pub _type: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub noWait: _bool,
    pub pushedDown: _bool,
}
impl ::std::default::Default for Struct_RowMarkClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowMarkClause = Struct_RowMarkClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_WithClause {
    pub _type: NodeTag,
    pub ctes: *mut List,
    pub recursive: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_WithClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithClause = Struct_WithClause;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CommonTableExpr {
    pub _type: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: _bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl ::std::default::Default for Struct_CommonTableExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommonTableExpr = Struct_CommonTableExpr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_InsertStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for Struct_InsertStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InsertStmt = Struct_InsertStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DeleteStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for Struct_DeleteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeleteStmt = Struct_DeleteStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_UpdateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::default::Default for Struct_UpdateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UpdateStmt = Struct_UpdateStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
pub type SetOperation = Enum_SetOperation;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SelectStmt {
    pub _type: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Struct_SelectStmt,
    pub rarg: *mut Struct_SelectStmt,
}
impl ::std::default::Default for Struct_SelectStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SelectStmt = Struct_SelectStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SetOperationStmt {
    pub _type: NodeTag,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl ::std::default::Default for Struct_SetOperationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetOperationStmt = Struct_SetOperationStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ObjectType {
    OBJECT_AGGREGATE = 0,
    OBJECT_ATTRIBUTE = 1,
    OBJECT_CAST = 2,
    OBJECT_COLUMN = 3,
    OBJECT_CONSTRAINT = 4,
    OBJECT_COLLATION = 5,
    OBJECT_CONVERSION = 6,
    OBJECT_DATABASE = 7,
    OBJECT_DOMAIN = 8,
    OBJECT_EVENT_TRIGGER = 9,
    OBJECT_EXTENSION = 10,
    OBJECT_FDW = 11,
    OBJECT_FOREIGN_SERVER = 12,
    OBJECT_FOREIGN_TABLE = 13,
    OBJECT_FUNCTION = 14,
    OBJECT_INDEX = 15,
    OBJECT_LANGUAGE = 16,
    OBJECT_LARGEOBJECT = 17,
    OBJECT_MATVIEW = 18,
    OBJECT_OPCLASS = 19,
    OBJECT_OPERATOR = 20,
    OBJECT_OPFAMILY = 21,
    OBJECT_ROLE = 22,
    OBJECT_RULE = 23,
    OBJECT_SCHEMA = 24,
    OBJECT_SEQUENCE = 25,
    OBJECT_TABLE = 26,
    OBJECT_TABLESPACE = 27,
    OBJECT_TRIGGER = 28,
    OBJECT_TSCONFIGURATION = 29,
    OBJECT_TSDICTIONARY = 30,
    OBJECT_TSPARSER = 31,
    OBJECT_TSTEMPLATE = 32,
    OBJECT_TYPE = 33,
    OBJECT_VIEW = 34,
}
pub type ObjectType = Enum_ObjectType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateSchemaStmt {
    pub _type: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authid: *mut ::std::os::raw::c_char,
    pub schemaElts: *mut List,
    pub if_not_exists: _bool,
}
impl ::std::default::Default for Struct_CreateSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSchemaStmt = Struct_CreateSchemaStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_DropBehavior { DROP_RESTRICT = 0, DROP_CASCADE = 1, }
pub type DropBehavior = Enum_DropBehavior;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTableStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableStmt = Struct_AlterTableStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_SetStatistics = 6,
    AT_SetOptions = 7,
    AT_ResetOptions = 8,
    AT_SetStorage = 9,
    AT_DropColumn = 10,
    AT_DropColumnRecurse = 11,
    AT_AddIndex = 12,
    AT_ReAddIndex = 13,
    AT_AddConstraint = 14,
    AT_AddConstraintRecurse = 15,
    AT_ReAddConstraint = 16,
    AT_AlterConstraint = 17,
    AT_ValidateConstraint = 18,
    AT_ValidateConstraintRecurse = 19,
    AT_ProcessedConstraint = 20,
    AT_AddIndexConstraint = 21,
    AT_DropConstraint = 22,
    AT_DropConstraintRecurse = 23,
    AT_AlterColumnType = 24,
    AT_AlterColumnGenericOptions = 25,
    AT_ChangeOwner = 26,
    AT_ClusterOn = 27,
    AT_DropCluster = 28,
    AT_AddOids = 29,
    AT_AddOidsRecurse = 30,
    AT_DropOids = 31,
    AT_SetTableSpace = 32,
    AT_SetRelOptions = 33,
    AT_ResetRelOptions = 34,
    AT_ReplaceRelOptions = 35,
    AT_EnableTrig = 36,
    AT_EnableAlwaysTrig = 37,
    AT_EnableReplicaTrig = 38,
    AT_DisableTrig = 39,
    AT_EnableTrigAll = 40,
    AT_DisableTrigAll = 41,
    AT_EnableTrigUser = 42,
    AT_DisableTrigUser = 43,
    AT_EnableRule = 44,
    AT_EnableAlwaysRule = 45,
    AT_EnableReplicaRule = 46,
    AT_DisableRule = 47,
    AT_AddInherit = 48,
    AT_DropInherit = 49,
    AT_AddOf = 50,
    AT_DropOf = 51,
    AT_ReplicaIdentity = 52,
    AT_GenericOptions = 53,
}
pub type AlterTableType = Enum_AlterTableType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReplicaIdentityStmt {
    pub _type: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_ReplicaIdentityStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicaIdentityStmt = Struct_ReplicaIdentityStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTableCmd {
    pub _type: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterTableCmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableCmd = Struct_AlterTableCmd;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterDomainStmt {
    pub _type: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDomainStmt = Struct_AlterDomainStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
pub type GrantTargetType = Enum_GrantTargetType;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_GrantObjectType {
    ACL_OBJECT_COLUMN = 0,
    ACL_OBJECT_RELATION = 1,
    ACL_OBJECT_SEQUENCE = 2,
    ACL_OBJECT_DATABASE = 3,
    ACL_OBJECT_DOMAIN = 4,
    ACL_OBJECT_FDW = 5,
    ACL_OBJECT_FOREIGN_SERVER = 6,
    ACL_OBJECT_FUNCTION = 7,
    ACL_OBJECT_LANGUAGE = 8,
    ACL_OBJECT_LARGEOBJECT = 9,
    ACL_OBJECT_NAMESPACE = 10,
    ACL_OBJECT_TABLESPACE = 11,
    ACL_OBJECT_TYPE = 12,
}
pub type GrantObjectType = Enum_GrantObjectType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_GrantStmt {
    pub _type: NodeTag,
    pub is_grant: _bool,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: _bool,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for Struct_GrantStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantStmt = Struct_GrantStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_PrivGrantee {
    pub _type: NodeTag,
    pub rolname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_PrivGrantee {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrivGrantee = Struct_PrivGrantee;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FuncWithArgs {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub funcargs: *mut List,
}
impl ::std::default::Default for Struct_FuncWithArgs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncWithArgs = Struct_FuncWithArgs;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AccessPriv {
    pub _type: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
impl ::std::default::Default for Struct_AccessPriv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AccessPriv = Struct_AccessPriv;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_GrantRoleStmt {
    pub _type: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: _bool,
    pub admin_opt: _bool,
    pub grantor: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for Struct_GrantRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantRoleStmt = Struct_GrantRoleStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterDefaultPrivilegesStmt {
    pub _type: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl ::std::default::Default for Struct_AlterDefaultPrivilegesStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDefaultPrivilegesStmt = Struct_AlterDefaultPrivilegesStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CopyStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: _bool,
    pub is_program: _bool,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CopyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CopyStmt = Struct_CopyStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed49 {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
pub type VariableSetKind = Enum_Unnamed49;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_VariableSetStmt {
    pub _type: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: _bool,
}
impl ::std::default::Default for Struct_VariableSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableSetStmt = Struct_VariableSetStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_VariableShowStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_VariableShowStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableShowStmt = Struct_VariableShowStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: _bool,
}
impl ::std::default::Default for Struct_CreateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateStmt = Struct_CreateStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_CHECK = 3,
    CONSTR_PRIMARY = 4,
    CONSTR_UNIQUE = 5,
    CONSTR_EXCLUSION = 6,
    CONSTR_FOREIGN = 7,
    CONSTR_ATTR_DEFERRABLE = 8,
    CONSTR_ATTR_NOT_DEFERRABLE = 9,
    CONSTR_ATTR_DEFERRED = 10,
    CONSTR_ATTR_IMMEDIATE = 11,
}
pub type ConstrType = Enum_ConstrType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Constraint {
    pub _type: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: _bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: _bool,
    pub initially_valid: _bool,
}
impl ::std::default::Default for Struct_Constraint {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Constraint = Struct_Constraint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut ::std::os::raw::c_char,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableSpaceStmt = Struct_CreateTableSpaceStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_DropTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropTableSpaceStmt = Struct_DropTableSpaceStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTableSpaceOptionsStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: _bool,
}
impl ::std::default::Default for Struct_AlterTableSpaceOptionsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableSpaceOptionsStmt = Struct_AlterTableSpaceOptionsStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTableMoveAllStmt {
    pub _type: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: _bool,
}
impl ::std::default::Default for Struct_AlterTableMoveAllStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableMoveAllStmt = Struct_AlterTableMoveAllStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: _bool,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateExtensionStmt = Struct_CreateExtensionStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_AlterExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionStmt = Struct_AlterExtensionStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterExtensionContentsStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
}
impl ::std::default::Default for Struct_AlterExtensionContentsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionContentsStmt = Struct_AlterExtensionContentsStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFdwStmt = Struct_CreateFdwStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_AlterFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFdwStmt = Struct_AlterFdwStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignServerStmt = Struct_CreateForeignServerStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: _bool,
}
impl ::std::default::Default for Struct_AlterForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterForeignServerStmt = Struct_AlterForeignServerStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateForeignTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignTableStmt = Struct_CreateForeignTableStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateUserMappingStmt = Struct_CreateUserMappingStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_AlterUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterUserMappingStmt = Struct_AlterUserMappingStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::std::os::raw::c_char,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_DropUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropUserMappingStmt = Struct_DropUserMappingStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: _bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub constrrel: *mut RangeVar,
}
impl ::std::default::Default for Struct_CreateTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTrigStmt = Struct_CreateTrigStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl ::std::default::Default for Struct_CreateEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEventTrigStmt = Struct_CreateEventTrigStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_AlterEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEventTrigStmt = Struct_AlterEventTrigStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreatePLangStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: _bool,
}
impl ::std::default::Default for Struct_CreatePLangStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatePLangStmt = Struct_CreatePLangStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
pub type RoleStmtType = Enum_RoleStmtType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateRoleStmt {
    pub _type: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreateRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRoleStmt = Struct_CreateRoleStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterRoleStmt {
    pub _type: NodeTag,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_AlterRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleStmt = Struct_AlterRoleStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterRoleSetStmt {
    pub _type: NodeTag,
    pub role: *mut ::std::os::raw::c_char,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::default::Default for Struct_AlterRoleSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleSetStmt = Struct_AlterRoleSetStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropRoleStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_DropRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropRoleStmt = Struct_DropRoleStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
}
impl ::std::default::Default for Struct_CreateSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSeqStmt = Struct_CreateSeqStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSeqStmt = Struct_AlterSeqStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DefineStmt {
    pub _type: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: _bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
}
impl ::std::default::Default for Struct_DefineStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefineStmt = Struct_DefineStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateDomainStmt {
    pub _type: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl ::std::default::Default for Struct_CreateDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateDomainStmt = Struct_CreateDomainStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateOpClassStmt {
    pub _type: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: _bool,
}
impl ::std::default::Default for Struct_CreateOpClassStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassStmt = Struct_CreateOpClassStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateOpClassItem {
    pub _type: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut List,
    pub args: *mut List,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl ::std::default::Default for Struct_CreateOpClassItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassItem = Struct_CreateOpClassItem;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_CreateOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpFamilyStmt = Struct_CreateOpFamilyStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: _bool,
    pub items: *mut List,
}
impl ::std::default::Default for Struct_AlterOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOpFamilyStmt = Struct_AlterOpFamilyStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropStmt {
    pub _type: NodeTag,
    pub objects: *mut List,
    pub arguments: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
    pub concurrent: _bool,
}
impl ::std::default::Default for Struct_DropStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropStmt = Struct_DropStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TruncateStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: _bool,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for Struct_TruncateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TruncateStmt = Struct_TruncateStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CommentStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub comment: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_CommentStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommentStmt = Struct_CommentStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SecLabelStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_SecLabelStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SecLabelStmt = Struct_SecLabelStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DeclareCursorStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
impl ::std::default::Default for Struct_DeclareCursorStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeclareCursorStmt = Struct_DeclareCursorStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ClosePortalStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_ClosePortalStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClosePortalStmt = Struct_ClosePortalStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
pub type FetchDirection = Enum_FetchDirection;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FetchStmt {
    pub _type: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: _bool,
}
impl ::std::default::Default for Struct_FetchStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FetchStmt = Struct_FetchStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_IndexStmt {
    pub _type: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: _bool,
    pub primary: _bool,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub concurrent: _bool,
}
impl ::std::default::Default for Struct_IndexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexStmt = Struct_IndexStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateFunctionStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
impl ::std::default::Default for Struct_CreateFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFunctionStmt = Struct_CreateFunctionStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
pub type FunctionParameterMode = Enum_FunctionParameterMode;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FunctionParameter {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl ::std::default::Default for Struct_FunctionParameter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionParameter = Struct_FunctionParameter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterFunctionStmt {
    pub _type: NodeTag,
    pub func: *mut FuncWithArgs,
    pub actions: *mut List,
}
impl ::std::default::Default for Struct_AlterFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFunctionStmt = Struct_AlterFunctionStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DoStmt {
    pub _type: NodeTag,
    pub args: *mut List,
}
impl ::std::default::Default for Struct_DoStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DoStmt = Struct_DoStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_InlineCodeBlock {
    pub _type: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: _bool,
}
impl ::std::default::Default for Struct_InlineCodeBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InlineCodeBlock = Struct_InlineCodeBlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RenameStmt {
    pub _type: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_RenameStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RenameStmt = Struct_RenameStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterObjectSchemaStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterObjectSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterObjectSchemaStmt = Struct_AlterObjectSchemaStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterOwnerStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newowner: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_AlterOwnerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOwnerStmt = Struct_AlterOwnerStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RuleStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: _bool,
    pub actions: *mut List,
    pub replace: _bool,
}
impl ::std::default::Default for Struct_RuleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleStmt = Struct_RuleStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_NotifyStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_NotifyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NotifyStmt = Struct_NotifyStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ListenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_ListenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ListenStmt = Struct_ListenStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_UnlistenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_UnlistenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UnlistenStmt = Struct_UnlistenStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
pub type TransactionStmtKind = Enum_TransactionStmtKind;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TransactionStmt {
    pub _type: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_TransactionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TransactionStmt = Struct_TransactionStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CompositeTypeStmt {
    pub _type: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl ::std::default::Default for Struct_CompositeTypeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CompositeTypeStmt = Struct_CompositeTypeStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl ::std::default::Default for Struct_CreateEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEnumStmt = Struct_CreateEnumStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateRangeStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl ::std::default::Default for Struct_CreateRangeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRangeStmt = Struct_CreateRangeStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: _bool,
    pub skipIfExists: _bool,
}
impl ::std::default::Default for Struct_AlterEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEnumStmt = Struct_AlterEnumStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ViewCheckOption {
    NO_CHECK_OPTION = 0,
    LOCAL_CHECK_OPTION = 1,
    CASCADED_CHECK_OPTION = 2,
}
pub type ViewCheckOption = Enum_ViewCheckOption;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ViewStmt {
    pub _type: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: _bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
impl ::std::default::Default for Struct_ViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewStmt = Struct_ViewStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LoadStmt {
    pub _type: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_LoadStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LoadStmt = Struct_LoadStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreatedbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_CreatedbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatedbStmt = Struct_CreatedbStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterDatabaseStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_AlterDatabaseStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseStmt = Struct_AlterDatabaseStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterDatabaseSetStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::default::Default for Struct_AlterDatabaseSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseSetStmt = Struct_AlterDatabaseSetStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropdbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_DropdbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropdbStmt = Struct_DropdbStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterSystemStmt {
    pub _type: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::default::Default for Struct_AlterSystemStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSystemStmt = Struct_AlterSystemStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ClusterStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: _bool,
}
impl ::std::default::Default for Struct_ClusterStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClusterStmt = Struct_ClusterStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_VacuumOption {
    VACOPT_VACUUM = 1,
    VACOPT_ANALYZE = 2,
    VACOPT_VERBOSE = 4,
    VACOPT_FREEZE = 8,
    VACOPT_FULL = 16,
    VACOPT_NOWAIT = 32,
}
pub type VacuumOption = Enum_VacuumOption;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_VacuumStmt {
    pub _type: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
}
impl ::std::default::Default for Struct_VacuumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VacuumStmt = Struct_VacuumStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ExplainStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_ExplainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExplainStmt = Struct_ExplainStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateTableAsStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: _bool,
}
impl ::std::default::Default for Struct_CreateTableAsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableAsStmt = Struct_CreateTableAsStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RefreshMatViewStmt {
    pub _type: NodeTag,
    pub concurrent: _bool,
    pub skipData: _bool,
    pub relation: *mut RangeVar,
}
impl ::std::default::Default for Struct_RefreshMatViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RefreshMatViewStmt = Struct_RefreshMatViewStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CheckPointStmt {
    pub _type: NodeTag,
}
impl ::std::default::Default for Struct_CheckPointStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckPointStmt = Struct_CheckPointStmt;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_DiscardMode {
    DISCARD_ALL = 0,
    DISCARD_PLANS = 1,
    DISCARD_SEQUENCES = 2,
    DISCARD_TEMP = 3,
}
pub type DiscardMode = Enum_DiscardMode;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DiscardStmt {
    pub _type: NodeTag,
    pub target: DiscardMode,
}
impl ::std::default::Default for Struct_DiscardStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DiscardStmt = Struct_DiscardStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LockStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: _bool,
}
impl ::std::default::Default for Struct_LockStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockStmt = Struct_LockStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ConstraintsSetStmt {
    pub _type: NodeTag,
    pub constraints: *mut List,
    pub deferred: _bool,
}
impl ::std::default::Default for Struct_ConstraintsSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstraintsSetStmt = Struct_ConstraintsSetStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReindexStmt {
    pub _type: NodeTag,
    pub kind: ObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub do_system: _bool,
    pub do_user: _bool,
}
impl ::std::default::Default for Struct_ReindexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReindexStmt = Struct_ReindexStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateConversionStmt {
    pub _type: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: _bool,
}
impl ::std::default::Default for Struct_CreateConversionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateConversionStmt = Struct_CreateConversionStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CreateCastStmt {
    pub _type: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut FuncWithArgs,
    pub context: CoercionContext,
    pub inout: _bool,
}
impl ::std::default::Default for Struct_CreateCastStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateCastStmt = Struct_CreateCastStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_PrepareStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl ::std::default::Default for Struct_PrepareStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrepareStmt = Struct_PrepareStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ExecuteStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl ::std::default::Default for Struct_ExecuteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExecuteStmt = Struct_ExecuteStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DeallocateStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_DeallocateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeallocateStmt = Struct_DeallocateStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DropOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl ::std::default::Default for Struct_DropOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropOwnedStmt = Struct_DropOwnedStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReassignOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_ReassignOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReassignOwnedStmt = Struct_ReassignOwnedStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTSDictionaryStmt {
    pub _type: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl ::std::default::Default for Struct_AlterTSDictionaryStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSDictionaryStmt = Struct_AlterTSDictionaryStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AlterTSConfigurationStmt {
    pub _type: NodeTag,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub _override: _bool,
    pub replace: _bool,
    pub missing_ok: _bool,
}
impl ::std::default::Default for Struct_AlterTSConfigurationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSConfigurationStmt = Struct_AlterTSConfigurationStmt;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_StringInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StringInfoData = Struct_StringInfoData;
pub type StringInfo = *mut StringInfoData;
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
impl ::std::default::Default for Struct_BlockIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BlockIdData = Struct_BlockIdData;
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ItemIdData {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_ItemIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemIdData = Struct_ItemIdData;
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl ::std::default::Default for Struct_ItemPointerData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemPointerData = Struct_ItemPointerData;
pub type ItemPointer = *mut ItemPointerData;
pub type HeapTupleHeaderData = Struct_HeapTupleHeaderData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTupleData = Struct_MinimalTupleData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl ::std::default::Default for Struct_HeapTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleData = Struct_HeapTupleData;
pub type HeapTuple = *mut HeapTupleData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl ::std::default::Default for Struct_OpBtreeInterpretation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpBtreeInterpretation = Struct_OpBtreeInterpretation;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
pub type IOFuncSelector = Enum_IOFuncSelector;
pub type get_attavgwidth_hook_type =
    ::std::option::Option<extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> int32>;
pub type aclitem = ::std::os::raw::c_int;
pub type pg_node_tree = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: _bool,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: _bool,
    pub atthasdef: _bool,
    pub attisdropped: _bool,
    pub attislocal: _bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl ::std::default::Default for Struct_FormData_pg_attribute {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_attribute = Struct_FormData_pg_attribute;
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_attrDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AttrDefault = Struct_attrDefault;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: _bool,
    pub ccnoinherit: _bool,
}
impl ::std::default::Default for Struct_constrCheck {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstrCheck = Struct_constrCheck;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: _bool,
}
impl ::std::default::Default for Struct_tupleConstr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleConstr = Struct_tupleConstr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: _bool,
    pub tdrefcount: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_tupleDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleDesc = *mut Struct_tupleDesc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
impl ::std::default::Default for Struct_flock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: Struct_timespec,
    pub st_mtim: Struct_timespec,
    pub st_ctim: Struct_timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
impl ::std::default::Default for Struct_stat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: TransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub latestCompletedXid: TransactionId,
}
impl ::std::default::Default for Struct_VariableCacheData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableCacheData = Struct_VariableCacheData;
pub type VariableCache = *mut VariableCacheData;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed50 {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
impl ::std::default::Default for Struct_Unnamed50 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageXLogRecPtr = Struct_Unnamed50;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: [ItemIdData; 1usize],
}
impl ::std::default::Default for Struct_PageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageHeaderData = Struct_PageHeaderData;
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: Union_Unnamed51,
}
impl ::std::default::Default for Struct_HeapTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed51 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed51 {
    pub unsafe fn t_cid(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_xvac(&mut self) -> *mut TransactionId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed51 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleFields = Struct_HeapTupleFields;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl ::std::default::Default for Struct_DatumTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DatumTupleFields = Struct_DatumTupleFields;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_HeapTupleHeaderData {
    pub t_choice: Union_Unnamed52,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::default::Default for Struct_HeapTupleHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed52 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed52 {
    pub unsafe fn t_heap(&mut self) -> *mut HeapTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_datum(&mut self) -> *mut DatumTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed52 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::default::Default for Struct_MinimalTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_node = Struct_dlist_node;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl ::std::default::Default for Struct_dlist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_dlist_head {
    pub head: dlist_node,
}
impl ::std::default::Default for Struct_dlist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_head = Struct_dlist_head;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::default::Default for Struct_dlist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_iter = Struct_dlist_iter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::default::Default for Struct_dlist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_mutable_iter = Struct_dlist_mutable_iter;
pub type slist_node = Struct_slist_node;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_slist_node {
    pub next: *mut slist_node,
}
impl ::std::default::Default for Struct_slist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_slist_head {
    pub head: slist_node,
}
impl ::std::default::Default for Struct_slist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_head = Struct_slist_head;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_slist_iter {
    pub cur: *mut slist_node,
}
impl ::std::default::Default for Struct_slist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_iter = Struct_slist_iter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl ::std::default::Default for Struct_slist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_mutable_iter = Struct_slist_mutable_iter;
#[derive(Copy, Clone)]
#[repr(i32)]
pub enum Enum_ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
pub type ForkNumber = Enum_ForkNumber;
pub type BackendId = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
impl ::std::default::Default for Struct_RelFileNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNode = Struct_RelFileNode;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
impl ::std::default::Default for Struct_RelFileNodeBackend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNodeBackend = Struct_RelFileNodeBackend;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed53 {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl ::std::default::Default for Struct_Unnamed53 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatcacheMsg = Struct_Unnamed53;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed54 {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl ::std::default::Default for Struct_Unnamed54 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatalogMsg = Struct_Unnamed54;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed55 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::default::Default for Struct_Unnamed55 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelcacheMsg = Struct_Unnamed55;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed56 {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
impl ::std::default::Default for Struct_Unnamed56 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSmgrMsg = Struct_Unnamed56;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed57 {
    pub id: int8,
    pub dbId: Oid,
}
impl ::std::default::Default for Struct_Unnamed57 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelmapMsg = Struct_Unnamed57;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed58 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::default::Default for Struct_Unnamed58 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSnapshotMsg = Struct_Unnamed58;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed59 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed59 {
    pub unsafe fn id(&mut self) -> *mut int8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cc(&mut self) -> *mut SharedInvalCatcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cat(&mut self) -> *mut SharedInvalCatalogMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rc(&mut self) -> *mut SharedInvalRelcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sm(&mut self) -> *mut SharedInvalSmgrMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rm(&mut self) -> *mut SharedInvalRelmapMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sn(&mut self) -> *mut SharedInvalSnapshotMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed59 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalidationMessage = Union_Unnamed59;
pub type HashValueFunc =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(dest:
                                                   *mut ::std::os::raw::c_void,
                                               src:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> *mut ::std::os::raw::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<extern "C" fn(request: Size)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_HASHELEMENT {
    pub link: *mut Struct_HASHELEMENT,
    pub hashvalue: uint32,
}
impl ::std::default::Default for Struct_HASHELEMENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHELEMENT = Struct_HASHELEMENT;
pub enum Struct_HASHHDR { }
pub type HASHHDR = Struct_HASHHDR;
pub enum Struct_HTAB { }
pub type HTAB = Struct_HTAB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub _match: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl ::std::default::Default for Struct_HASHCTL {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHCTL = Struct_HASHCTL;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed60 {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
pub type HASHACTION = Enum_Unnamed60;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed61 {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl ::std::default::Default for Struct_Unnamed61 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASH_SEQ_STATUS = Struct_Unnamed61;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FormData_pg_am {
    pub amname: NameData,
    pub amstrategies: int16,
    pub amsupport: int16,
    pub amcanorder: _bool,
    pub amcanorderbyop: _bool,
    pub amcanbackward: _bool,
    pub amcanunique: _bool,
    pub amcanmulticol: _bool,
    pub amoptionalkey: _bool,
    pub amsearcharray: _bool,
    pub amsearchnulls: _bool,
    pub amstorage: _bool,
    pub amclusterable: _bool,
    pub ampredlocks: _bool,
    pub amkeytype: Oid,
    pub aminsert: regproc,
    pub ambeginscan: regproc,
    pub amgettuple: regproc,
    pub amgetbitmap: regproc,
    pub amrescan: regproc,
    pub amendscan: regproc,
    pub ammarkpos: regproc,
    pub amrestrpos: regproc,
    pub ambuild: regproc,
    pub ambuildempty: regproc,
    pub ambulkdelete: regproc,
    pub amvacuumcleanup: regproc,
    pub amcanreturn: regproc,
    pub amcostestimate: regproc,
    pub amoptions: regproc,
}
impl ::std::default::Default for Struct_FormData_pg_am {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_am = Struct_FormData_pg_am;
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: _bool,
    pub relisshared: _bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: _bool,
    pub relhaspkey: _bool,
    pub relhasrules: _bool,
    pub relhastriggers: _bool,
    pub relhassubclass: _bool,
    pub relispopulated: _bool,
    pub relreplident: ::std::os::raw::c_char,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl ::std::default::Default for Struct_FormData_pg_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_class = Struct_FormData_pg_class;
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: _bool,
    pub indisprimary: _bool,
    pub indisexclusion: _bool,
    pub indimmediate: _bool,
    pub indisclustered: _bool,
    pub indisvalid: _bool,
    pub indcheckxmin: _bool,
    pub indisready: _bool,
    pub indislive: _bool,
    pub indisreplident: _bool,
    pub indkey: int2vector,
}
impl ::std::default::Default for Struct_FormData_pg_index {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_index = Struct_FormData_pg_index;
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: _bool,
}
impl ::std::default::Default for Struct_RewriteRule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RewriteRule = Struct_RewriteRule;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl ::std::default::Default for Struct_RuleLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleLock = Struct_RuleLock;
pub type Relation = *mut Struct_RelationData;
pub type RelationPtr = *mut Relation;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_IndexAttrBitmapKind {
    INDEX_ATTR_BITMAP_ALL = 0,
    INDEX_ATTR_BITMAP_KEY = 1,
    INDEX_ATTR_BITMAP_IDENTITY_KEY = 2,
}
pub type IndexAttrBitmapKind = Enum_IndexAttrBitmapKind;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: _bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: _bool,
    pub tginitdeferred: _bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_Trigger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Trigger = Struct_Trigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: _bool,
    pub trig_insert_after_row: _bool,
    pub trig_insert_instead_row: _bool,
    pub trig_insert_before_statement: _bool,
    pub trig_insert_after_statement: _bool,
    pub trig_update_before_row: _bool,
    pub trig_update_after_row: _bool,
    pub trig_update_instead_row: _bool,
    pub trig_update_before_statement: _bool,
    pub trig_update_after_statement: _bool,
    pub trig_delete_before_row: _bool,
    pub trig_delete_after_row: _bool,
    pub trig_delete_instead_row: _bool,
    pub trig_delete_before_statement: _bool,
    pub trig_delete_after_statement: _bool,
    pub trig_truncate_before_statement: _bool,
    pub trig_truncate_after_statement: _bool,
}
impl ::std::default::Default for Struct_TriggerDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TriggerDesc = Struct_TriggerDesc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl ::std::default::Default for Struct_LockRelId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockRelId = Struct_LockRelId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LockInfoData {
    pub lockRelId: LockRelId,
}
impl ::std::default::Default for Struct_LockInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInfoData = Struct_LockInfoData;
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RelationAmInfo {
    pub aminsert: FmgrInfo,
    pub ambeginscan: FmgrInfo,
    pub amgettuple: FmgrInfo,
    pub amgetbitmap: FmgrInfo,
    pub amrescan: FmgrInfo,
    pub amendscan: FmgrInfo,
    pub ammarkpos: FmgrInfo,
    pub amrestrpos: FmgrInfo,
    pub amcanreturn: FmgrInfo,
}
impl ::std::default::Default for Struct_RelationAmInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationAmInfo = Struct_RelationAmInfo;
pub enum Struct_SMgrRelationData { }
pub enum Struct_FdwRoutine { }
pub enum Struct_PgStat_TableStatus { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut Struct_SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: _bool,
    pub rd_isnailed: _bool,
    pub rd_isvalid: _bool,
    pub rd_indexvalid: ::std::os::raw::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut Struct_HeapTupleData,
    pub rd_am: Form_pg_am,
    pub rd_indexcxt: MemoryContext,
    pub rd_aminfo: *mut RelationAmInfo,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut Struct_FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut Struct_PgStat_TableStatus,
}
impl ::std::default::Default for Struct_RelationData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationData = Struct_RelationData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_AutoVacOpts {
    pub enabled: _bool,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_delay: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
impl ::std::default::Default for Struct_AutoVacOpts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AutoVacOpts = Struct_AutoVacOpts;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: _bool,
}
impl ::std::default::Default for Struct_StdRdOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StdRdOptions = Struct_StdRdOptions;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: _bool,
    pub check_option_offset: ::std::os::raw::c_int,
}
impl ::std::default::Default for Struct_ViewOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewOptions = Struct_ViewOptions;
pub type Buffer = ::std::os::raw::c_int;
pub enum Struct_BufferAccessStrategyData { }
pub type BufferAccessStrategy = *mut Struct_BufferAccessStrategyData;
pub type Snapshot = *mut Struct_SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<extern "C" fn(htup: HeapTuple, snapshot: Snapshot,
                                        buffer: Buffer) -> _bool>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxcnt: int32,
    pub subxip: *mut TransactionId,
    pub suboverflowed: _bool,
    pub takenDuringRecovery: _bool,
    pub copied: _bool,
    pub curcid: CommandId,
    pub active_count: uint32,
    pub regd_count: uint32,
}
impl ::std::default::Default for Struct_SnapshotData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SnapshotData = Struct_SnapshotData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed62 {
    HeapTupleMayBeUpdated = 0,
    HeapTupleInvisible = 1,
    HeapTupleSelfUpdated = 2,
    HeapTupleUpdated = 3,
    HeapTupleBeingUpdated = 4,
}
pub type HTSU_Result = Enum_Unnamed62;
pub type float_t = ::std::os::raw::c_float;
pub type double_t = ::std::os::raw::c_double;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed63 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
#[derive(Copy, Clone)]
#[repr(i32)]
pub enum Enum_Unnamed64 {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
pub type _LIB_VERSION_TYPE = Enum_Unnamed64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_exception {
    pub _type: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_double,
    pub arg2: ::std::os::raw::c_double,
    pub retval: ::std::os::raw::c_double,
}
impl ::std::default::Default for Struct_exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed65 {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
impl ::std::default::Default for Struct_Unnamed65 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Interval = Struct_Unnamed65;
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_pg_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pg_tz { }
pub type pg_tz = Struct_pg_tz;
pub enum Struct_pg_tzenum { }
pub type pg_tzenum = Struct_pg_tzenum;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub alloc_tuple_size: Size,
}
impl ::std::default::Default for Struct_ReorderBufferTupleBuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTupleBuf = Struct_ReorderBufferTupleBuf;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ReorderBufferChangeType {
    REORDER_BUFFER_CHANGE_INSERT = 0,
    REORDER_BUFFER_CHANGE_UPDATE = 1,
    REORDER_BUFFER_CHANGE_DELETE = 2,
    REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT = 3,
    REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID = 4,
    REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: Enum_ReorderBufferChangeType,
    pub data: Union_Unnamed66,
    pub node: dlist_node,
}
impl ::std::default::Default for Struct_ReorderBufferChange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_Unnamed66 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed66 {
    pub unsafe fn tp(&mut self) -> *mut Struct_Unnamed67 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn snapshot(&mut self) -> *mut Snapshot {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn command_id(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tuplecid(&mut self) -> *mut Struct_Unnamed68 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed66 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed67 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: _bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl ::std::default::Default for Struct_Unnamed67 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_Unnamed68 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl ::std::default::Default for Struct_Unnamed68 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferChange = Struct_ReorderBufferChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReorderBufferTXN {
    pub xid: TransactionId,
    pub has_catalog_changes: _bool,
    pub is_known_as_subxact: _bool,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
}
impl ::std::default::Default for Struct_ReorderBufferTXN {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTXN = Struct_ReorderBufferTXN;
pub type ReorderBuffer = Struct_ReorderBuffer;
pub type ReorderBufferApplyChangeCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferCommitCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub commit: ReorderBufferCommitCB,
    pub private_data: *mut ::std::os::raw::c_void,
    pub context: MemoryContext,
    pub cached_transactions: dlist_head,
    pub nr_cached_transactions: Size,
    pub cached_changes: dlist_head,
    pub nr_cached_changes: Size,
    pub cached_tuplebufs: slist_head,
    pub nr_cached_tuplebufs: Size,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::std::os::raw::c_char,
    pub outbufsize: Size,
}
impl ::std::default::Default for Struct_ReorderBuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_OutputPluginOutputType {
    OUTPUT_PLUGIN_BINARY_OUTPUT = 0,
    OUTPUT_PLUGIN_TEXTUAL_OUTPUT = 1,
}
pub type OutputPluginOutputType = Enum_OutputPluginOutputType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
}
impl ::std::default::Default for Struct_OutputPluginOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginOptions = Struct_OutputPluginOptions;
pub type LogicalOutputPluginInit =
    ::std::option::Option<unsafe extern "C" fn(cb:
                                                   *mut Struct_OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut Struct_LogicalDecodingContext,
                                               options:
                                                   *mut OutputPluginOptions,
                                               is_init: _bool)>;
pub type LogicalDecodeBeginCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN)>;
pub type LogicalDecodeChangeCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type LogicalDecodeCommitCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
impl ::std::default::Default for Struct_OutputPluginCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginCallbacks = Struct_OutputPluginCallbacks;
pub type RmgrId = uint8;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_RmgrIds {
    RM_XLOG_ID = 0,
    RM_XACT_ID = 1,
    RM_SMGR_ID = 2,
    RM_CLOG_ID = 3,
    RM_DBASE_ID = 4,
    RM_TBLSPC_ID = 5,
    RM_MULTIXACT_ID = 6,
    RM_RELMAP_ID = 7,
    RM_STANDBY_ID = 8,
    RM_HEAP2_ID = 9,
    RM_HEAP_ID = 10,
    RM_BTREE_ID = 11,
    RM_HASH_ID = 12,
    RM_GIN_ID = 13,
    RM_GIST_ID = 14,
    RM_SEQ_ID = 15,
    RM_SPGIST_ID = 16,
    RM_NEXT_ID = 17,
}
pub type RmgrIds = Enum_RmgrIds;
pub type pg_crc32 = uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_len: uint32,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_prev: XLogRecPtr,
    pub xl_crc: pg_crc32,
}
impl ::std::default::Default for Struct_XLogRecord {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecord = Struct_XLogRecord;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XLogRecData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: uint32,
    pub buffer: Buffer,
    pub buffer_std: _bool,
    pub next: *mut Struct_XLogRecData,
}
impl ::std::default::Default for Struct_XLogRecData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecData = Struct_XLogRecData;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed69 {
    STANDBY_DISABLED = 0,
    STANDBY_INITIALIZED = 1,
    STANDBY_SNAPSHOT_PENDING = 2,
    STANDBY_SNAPSHOT_READY = 3,
}
pub type HotStandbyState = Enum_Unnamed69;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_Unnamed70 {
    RECOVERY_TARGET_UNSET = 0,
    RECOVERY_TARGET_XID = 1,
    RECOVERY_TARGET_TIME = 2,
    RECOVERY_TARGET_NAME = 3,
    RECOVERY_TARGET_IMMEDIATE = 4,
}
pub type RecoveryTargetType = Enum_Unnamed70;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_WalLevel {
    WAL_LEVEL_MINIMAL = 0,
    WAL_LEVEL_ARCHIVE = 1,
    WAL_LEVEL_HOT_STANDBY = 2,
    WAL_LEVEL_LOGICAL = 3,
}
pub type WalLevel = Enum_WalLevel;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
impl ::std::default::Default for Struct_CheckpointStatsData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckpointStatsData = Struct_CheckpointStatsData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_BkpBlock {
    pub node: RelFileNode,
    pub fork: ForkNumber,
    pub block: BlockNumber,
    pub hole_offset: uint16,
    pub hole_length: uint16,
}
impl ::std::default::Default for Struct_BkpBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BkpBlock = Struct_BkpBlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XLogPageHeaderData {
    pub xlp_magic: uint16,
    pub xlp_info: uint16,
    pub xlp_tli: TimeLineID,
    pub xlp_pageaddr: XLogRecPtr,
    pub xlp_rem_len: uint32,
}
impl ::std::default::Default for Struct_XLogPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogPageHeaderData = Struct_XLogPageHeaderData;
pub type XLogPageHeader = *mut XLogPageHeaderData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XLogLongPageHeaderData {
    pub std: XLogPageHeaderData,
    pub xlp_sysid: uint64,
    pub xlp_seg_size: uint32,
    pub xlp_xlog_blcksz: uint32,
}
impl ::std::default::Default for Struct_XLogLongPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogLongPageHeaderData = Struct_XLogLongPageHeaderData;
pub type XLogLongPageHeader = *mut XLogLongPageHeaderData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_xl_parameter_change {
    pub MaxConnections: ::std::os::raw::c_int,
    pub max_worker_processes: ::std::os::raw::c_int,
    pub max_prepared_xacts: ::std::os::raw::c_int,
    pub max_locks_per_xact: ::std::os::raw::c_int,
    pub wal_level: ::std::os::raw::c_int,
    pub wal_log_hints: _bool,
}
impl ::std::default::Default for Struct_xl_parameter_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_parameter_change = Struct_xl_parameter_change;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_restore_point {
    pub rp_time: TimestampTz,
    pub rp_name: [::std::os::raw::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_xl_restore_point {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_restore_point {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_restore_point = Struct_xl_restore_point;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_xl_end_of_recovery {
    pub end_time: TimestampTz,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
}
impl ::std::default::Default for Struct_xl_end_of_recovery {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_end_of_recovery = Struct_xl_end_of_recovery;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_RmgrData {
    pub rm_name: *const ::std::os::raw::c_char,
    pub rm_redo: ::std::option::Option<unsafe extern "C" fn(lsn: XLogRecPtr,
                                                            rptr:
                                                                *mut Struct_XLogRecord)>,
    pub rm_desc: ::std::option::Option<unsafe extern "C" fn(buf: StringInfo,
                                                            xl_info: uint8,
                                                            rec:
                                                                *mut ::std::os::raw::c_char)>,
    pub rm_startup: ::std::option::Option<extern "C" fn()>,
    pub rm_cleanup: ::std::option::Option<extern "C" fn()>,
}
impl ::std::default::Default for Struct_RmgrData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RmgrData = Struct_RmgrData;
pub type XLogReaderState = Struct_XLogReaderState;
pub type XLogPageReadCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader:
                                                   *mut XLogReaderState,
                                               targetPagePtr: XLogRecPtr,
                                               reqLen: ::std::os::raw::c_int,
                                               targetRecPtr: XLogRecPtr,
                                               readBuf:
                                                   *mut ::std::os::raw::c_char,
                                               pageTLI: *mut TimeLineID)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readLen: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
}
impl ::std::default::Default for Struct_XLogReaderState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slock_t = ::std::os::raw::c_uchar;
pub enum Struct_PGPROC { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LWLockTranche {
    pub name: *const ::std::os::raw::c_char,
    pub array_base: *mut ::std::os::raw::c_void,
    pub array_stride: Size,
}
impl ::std::default::Default for Struct_LWLockTranche {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockTranche = Struct_LWLockTranche;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LWLock {
    pub mutex: slock_t,
    pub releaseOK: _bool,
    pub exclusive: ::std::os::raw::c_char,
    pub shared: ::std::os::raw::c_int,
    pub tranche: ::std::os::raw::c_int,
    pub head: *mut Struct_PGPROC,
    pub tail: *mut Struct_PGPROC,
}
impl ::std::default::Default for Struct_LWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLock = Struct_LWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Union_LWLockPadded {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_LWLockPadded {
    pub unsafe fn lock(&mut self) -> *mut LWLock {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pad(&mut self) -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_LWLockPadded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockPadded = Union_LWLockPadded;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
pub type LWLockMode = Enum_LWLockMode;
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_SHM_QUEUE {
    pub prev: *mut Struct_SHM_QUEUE,
    pub next: *mut Struct_SHM_QUEUE,
}
impl ::std::default::Default for Struct_SHM_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SHM_QUEUE = Struct_SHM_QUEUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed71 {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl ::std::clone::Clone for Struct_Unnamed71 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed71 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ShmemIndexEnt = Struct_Unnamed71;
#[derive(Copy, Clone)]
#[repr(u32)]
pub enum Enum_ReplicationSlotPersistency {
    RS_PERSISTENT = 0,
    RS_EPHEMERAL = 1,
}
pub type ReplicationSlotPersistency = Enum_ReplicationSlotPersistency;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub confirmed_flush: XLogRecPtr,
    pub plugin: NameData,
}
impl ::std::default::Default for Struct_ReplicationSlotPersistentData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotPersistentData = Struct_ReplicationSlotPersistentData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: _bool,
    pub active: _bool,
    pub just_dirtied: _bool,
    pub dirty: _bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: *mut LWLock,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
impl ::std::default::Default for Struct_ReplicationSlot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlot = Struct_ReplicationSlot;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl ::std::default::Default for Struct_ReplicationSlotCtlData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotCtlData = Struct_ReplicationSlotCtlData;
pub type LogicalOutputPluginWriterWrite =
    ::std::option::Option<unsafe extern "C" fn(lr:
                                                   *mut Struct_LogicalDecodingContext,
                                               Ptr: XLogRecPtr,
                                               xid: TransactionId,
                                               last_write: _bool)>;
pub type LogicalOutputPluginWriterPrepareWrite =
    LogicalOutputPluginWriterWrite;
pub enum Struct_SnapBuild { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct_LogicalDecodingContext {
    pub context: MemoryContext,
    pub reader: *mut XLogReaderState,
    pub slot: *mut ReplicationSlot,
    pub reorder: *mut Struct_ReorderBuffer,
    pub snapshot_builder: *mut Struct_SnapBuild,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::std::os::raw::c_void,
    pub output_writer_private: *mut ::std::os::raw::c_void,
    pub accept_writes: _bool,
    pub prepared_write: _bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
}
impl ::std::default::Default for Struct_LogicalDecodingContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LogicalDecodingContext = Struct_LogicalDecodingContext;
pub type __builtin_va_list = [Struct___va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for Struct___va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: *mut Struct__IO_FILE;
    pub static mut stdout: *mut Struct__IO_FILE;
    pub static mut stderr: *mut Struct__IO_FILE;
    pub static mut sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
    pub static in6addr_any: Struct_in6_addr;
    pub static in6addr_loopback: Struct_in6_addr;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
    pub static mut Log_destination: ::std::os::raw::c_int;
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut assert_enabled: _bool;
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static mut extra_float_digits: ::std::os::raw::c_int;
    pub static mut quote_all_identifiers: _bool;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub static mut ShmemVariableCache: VariableCache;
    pub static mut forkNames: [*const ::std::os::raw::c_char; 0usize];
    pub static mut MyBackendId: BackendId;
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut no_such_variable: ::std::os::raw::c_int;
    pub static mut criticalRelcachesBuilt: _bool;
    pub static mut criticalSharedRelcachesBuilt: _bool;
    pub static mut signgam: ::std::os::raw::c_int;
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub static mut pg_crc32_table: [uint32; 0usize];
    pub static mut sync_method: ::std::os::raw::c_int;
    pub static mut ThisTimeLineID: TimeLineID;
    pub static mut InRecovery: _bool;
    pub static mut standbyState: HotStandbyState;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut reachedConsistency: _bool;
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
    pub static mut wal_keep_segments: ::std::os::raw::c_int;
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
    pub static mut XLogArchiveMode: _bool;
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
    pub static mut EnableHotStandby: _bool;
    pub static mut fullPageWrites: _bool;
    pub static mut wal_log_hints: _bool;
    pub static mut log_checkpoints: _bool;
    pub static mut wal_level: ::std::os::raw::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub static mut RmgrTable: [RmgrData; 0usize];
    pub static mut ArchiveRecoveryRequested: _bool;
    pub static mut InArchiveRecovery: _bool;
    pub static mut StandbyMode: _bool;
    pub static mut recoveryRestoreCommand: *mut ::std::os::raw::c_char;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: __gnuc_va_list, arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: size_t) -> size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: size_t,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut size_t) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                     __format: *const ::std::os::raw::c_char,
                     __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut size_t, __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                 __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: size_t,
                  __n: size_t, __s: *mut FILE) -> size_t;
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                          __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: size_t, __n: size_t, __stream: *mut FILE)
     -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const Struct_timespec,
                   __sigmask: *const __sigset_t) -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn srandom(__seed: ::std::os::raw::c_uint);
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: size_t) -> *mut ::std::os::raw::c_char;
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t)
     -> ::std::os::raw::c_int;
    pub fn srandom_r(__seed: ::std::os::raw::c_uint,
                     __buf: *mut Struct_random_data) -> ::std::os::raw::c_int;
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: size_t, __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn srand(__seed: ::std::os::raw::c_uint);
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn drand48() -> ::std::os::raw::c_double;
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn srand48(__seedval: ::std::os::raw::c_long);
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
    pub fn alloca(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: size_t, __size: size_t)
     -> ::std::os::raw::c_int;
    pub fn aligned_alloc(__alignment: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn at_quick_exit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn exit(__status: ::std::os::raw::c_int);
    pub fn quick_exit(__status: ::std::os::raw::c_int);
    pub fn _Exit(__status: ::std::os::raw::c_int);
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn clearenv() -> ::std::os::raw::c_int;
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: size_t,
                 __size: size_t, __compar: __compar_fn_t);
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn ecvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn fcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn gcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn qecvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qfcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qgcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ecvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn fcvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qecvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qfcvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: size_t) -> ::std::os::raw::c_int;
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: size_t) -> size_t;
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: size_t) -> size_t;
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *mut ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getloadavg(__loadavg: *mut ::std::os::raw::c_double,
                      __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_ulong;
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t)
     -> size_t;
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
    pub fn setlocale(__category: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn localeconv() -> *mut Struct_lconv;
    pub fn newlocale(__category_mask: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char,
                     __base: __locale_t) -> __locale_t;
    pub fn duplocale(__dataset: __locale_t) -> __locale_t;
    pub fn freelocale(__dataset: __locale_t);
    pub fn uselocale(__dataset: __locale_t) -> __locale_t;
    pub fn gettext(__msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dgettext(__domainname: *const ::std::os::raw::c_char,
                    __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __dgettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dcgettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid: *const ::std::os::raw::c_char,
                     __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __dcgettext(__domainname: *const ::std::os::raw::c_char,
                       __msgid: *const ::std::os::raw::c_char,
                       __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ngettext(__msgid1: *const ::std::os::raw::c_char,
                    __msgid2: *const ::std::os::raw::c_char,
                    __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
    pub fn dngettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid1: *const ::std::os::raw::c_char,
                     __msgid2: *const ::std::os::raw::c_char,
                     __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
    pub fn dcngettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid1: *const ::std::os::raw::c_char,
                      __msgid2: *const ::std::os::raw::c_char,
                      __n: ::std::os::raw::c_ulong,
                      __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn textdomain(__domainname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bindtextdomain(__domainname: *const ::std::os::raw::c_char,
                          __dirname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bind_textdomain_codeset(__domainname:
                                       *const ::std::os::raw::c_char,
                                   __codeset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                 __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                  __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn __cmsg_nxthdr(__mhdr: *mut Struct_msghdr,
                         __cmsg: *mut Struct_cmsghdr) -> *mut Struct_cmsghdr;
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const Struct_sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
    pub fn getsockname(__fd: ::std::os::raw::c_int,
                       __addr: *mut Struct_sockaddr, __len: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn connect(__fd: ::std::os::raw::c_int,
                   __addr: *const Struct_sockaddr, __len: socklen_t)
     -> ::std::os::raw::c_int;
    pub fn getpeername(__fd: ::std::os::raw::c_int,
                       __addr: *mut Struct_sockaddr, __len: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: size_t,
                  __flags: ::std::os::raw::c_int,
                  __addr: *const Struct_sockaddr, __addr_len: socklen_t)
     -> ssize_t;
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: size_t,
                    __flags: ::std::os::raw::c_int,
                    __addr: *mut Struct_sockaddr, __addr_len: *mut socklen_t)
     -> ssize_t;
    pub fn sendmsg(__fd: ::std::os::raw::c_int,
                   __message: *const Struct_msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut Struct_msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut Struct_sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ntohl(__netlong: uint32_t) -> uint32_t;
    pub fn ntohs(__netshort: uint16_t) -> uint16_t;
    pub fn htonl(__hostlong: uint32_t) -> uint32_t;
    pub fn htons(__hostshort: uint16_t) -> uint16_t;
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut Struct_sockaddr_in)
     -> ::std::os::raw::c_int;
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut Struct_sockaddr_in6)
     -> ::std::os::raw::c_int;
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
    pub fn endrpcent();
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char)
     -> *mut Struct_rpcent;
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int)
     -> *mut Struct_rpcent;
    pub fn getrpcent() -> *mut Struct_rpcent;
    pub fn getrpcbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut Struct_rpcent,
                          __buffer: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut Struct_rpcent)
     -> ::std::os::raw::c_int;
    pub fn getrpcbynumber_r(__number: ::std::os::raw::c_int,
                            __result_buf: *mut Struct_rpcent,
                            __buffer: *mut ::std::os::raw::c_char,
                            __buflen: size_t,
                            __result: *mut *mut Struct_rpcent)
     -> ::std::os::raw::c_int;
    pub fn getrpcent_r(__result_buf: *mut Struct_rpcent,
                       __buffer: *mut ::std::os::raw::c_char,
                       __buflen: size_t, __result: *mut *mut Struct_rpcent)
     -> ::std::os::raw::c_int;
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
    pub fn herror(__str: *const ::std::os::raw::c_char);
    pub fn hstrerror(__err_num: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
    pub fn endhostent();
    pub fn gethostent() -> *mut Struct_hostent;
    pub fn gethostbyaddr(__addr: *const ::std::os::raw::c_void,
                         __len: __socklen_t, __type: ::std::os::raw::c_int)
     -> *mut Struct_hostent;
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char)
     -> *mut Struct_hostent;
    pub fn gethostbyname2(__name: *const ::std::os::raw::c_char,
                          __af: ::std::os::raw::c_int) -> *mut Struct_hostent;
    pub fn gethostent_r(__result_buf: *mut Struct_hostent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                        __result: *mut *mut Struct_hostent,
                        __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyaddr_r(__addr: *const ::std::os::raw::c_void,
                           __len: __socklen_t, __type: ::std::os::raw::c_int,
                           __result_buf: *mut Struct_hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t,
                           __result: *mut *mut Struct_hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyname_r(__name: *const ::std::os::raw::c_char,
                           __result_buf: *mut Struct_hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t,
                           __result: *mut *mut Struct_hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn gethostbyname2_r(__name: *const ::std::os::raw::c_char,
                            __af: ::std::os::raw::c_int,
                            __result_buf: *mut Struct_hostent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: size_t,
                            __result: *mut *mut Struct_hostent,
                            __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
    pub fn endnetent();
    pub fn getnetent() -> *mut Struct_netent;
    pub fn getnetbyaddr(__net: uint32_t, __type: ::std::os::raw::c_int)
     -> *mut Struct_netent;
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char)
     -> *mut Struct_netent;
    pub fn getnetent_r(__result_buf: *mut Struct_netent,
                       __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                       __result: *mut *mut Struct_netent,
                       __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getnetbyaddr_r(__net: uint32_t, __type: ::std::os::raw::c_int,
                          __result_buf: *mut Struct_netent,
                          __buf: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut Struct_netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getnetbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut Struct_netent,
                          __buf: *mut ::std::os::raw::c_char,
                          __buflen: size_t, __result: *mut *mut Struct_netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
    pub fn endservent();
    pub fn getservent() -> *mut Struct_servent;
    pub fn getservbyname(__name: *const ::std::os::raw::c_char,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut Struct_servent;
    pub fn getservbyport(__port: ::std::os::raw::c_int,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut Struct_servent;
    pub fn getservent_r(__result_buf: *mut Struct_servent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                        __result: *mut *mut Struct_servent)
     -> ::std::os::raw::c_int;
    pub fn getservbyname_r(__name: *const ::std::os::raw::c_char,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut Struct_servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t,
                           __result: *mut *mut Struct_servent)
     -> ::std::os::raw::c_int;
    pub fn getservbyport_r(__port: ::std::os::raw::c_int,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut Struct_servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: size_t,
                           __result: *mut *mut Struct_servent)
     -> ::std::os::raw::c_int;
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
    pub fn endprotoent();
    pub fn getprotoent() -> *mut Struct_protoent;
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char)
     -> *mut Struct_protoent;
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int)
     -> *mut Struct_protoent;
    pub fn getprotoent_r(__result_buf: *mut Struct_protoent,
                         __buf: *mut ::std::os::raw::c_char, __buflen: size_t,
                         __result: *mut *mut Struct_protoent)
     -> ::std::os::raw::c_int;
    pub fn getprotobyname_r(__name: *const ::std::os::raw::c_char,
                            __result_buf: *mut Struct_protoent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: size_t,
                            __result: *mut *mut Struct_protoent)
     -> ::std::os::raw::c_int;
    pub fn getprotobynumber_r(__proto: ::std::os::raw::c_int,
                              __result_buf: *mut Struct_protoent,
                              __buf: *mut ::std::os::raw::c_char,
                              __buflen: size_t,
                              __result: *mut *mut Struct_protoent)
     -> ::std::os::raw::c_int;
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn endnetgrent();
    pub fn getnetgrent(__hostp: *mut *mut ::std::os::raw::c_char,
                       __userp: *mut *mut ::std::os::raw::c_char,
                       __domainp: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn innetgr(__netgroup: *const ::std::os::raw::c_char,
                   __host: *const ::std::os::raw::c_char,
                   __user: *const ::std::os::raw::c_char,
                   __domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getnetgrent_r(__hostp: *mut *mut ::std::os::raw::c_char,
                         __userp: *mut *mut ::std::os::raw::c_char,
                         __domainp: *mut *mut ::std::os::raw::c_char,
                         __buffer: *mut ::std::os::raw::c_char,
                         __buflen: size_t) -> ::std::os::raw::c_int;
    pub fn rcmd(__ahost: *mut *mut ::std::os::raw::c_char,
                __rport: ::std::os::raw::c_ushort,
                __locuser: *const ::std::os::raw::c_char,
                __remuser: *const ::std::os::raw::c_char,
                __cmd: *const ::std::os::raw::c_char,
                __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rcmd_af(__ahost: *mut *mut ::std::os::raw::c_char,
                   __rport: ::std::os::raw::c_ushort,
                   __locuser: *const ::std::os::raw::c_char,
                   __remuser: *const ::std::os::raw::c_char,
                   __cmd: *const ::std::os::raw::c_char,
                   __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
    pub fn rexec(__ahost: *mut *mut ::std::os::raw::c_char,
                 __rport: ::std::os::raw::c_int,
                 __name: *const ::std::os::raw::c_char,
                 __pass: *const ::std::os::raw::c_char,
                 __cmd: *const ::std::os::raw::c_char,
                 __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rexec_af(__ahost: *mut *mut ::std::os::raw::c_char,
                    __rport: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __pass: *const ::std::os::raw::c_char,
                    __cmd: *const ::std::os::raw::c_char,
                    __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
    pub fn ruserok(__rhost: *const ::std::os::raw::c_char,
                   __suser: ::std::os::raw::c_int,
                   __remuser: *const ::std::os::raw::c_char,
                   __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn ruserok_af(__rhost: *const ::std::os::raw::c_char,
                      __suser: ::std::os::raw::c_int,
                      __remuser: *const ::std::os::raw::c_char,
                      __locuser: *const ::std::os::raw::c_char,
                      __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn iruserok(__raddr: uint32_t, __suser: ::std::os::raw::c_int,
                    __remuser: *const ::std::os::raw::c_char,
                    __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn iruserok_af(__raddr: *const ::std::os::raw::c_void,
                       __suser: ::std::os::raw::c_int,
                       __remuser: *const ::std::os::raw::c_char,
                       __locuser: *const ::std::os::raw::c_char,
                       __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rresvport_af(__alport: *mut ::std::os::raw::c_int,
                        __af: sa_family_t) -> ::std::os::raw::c_int;
    pub fn getaddrinfo(__name: *const ::std::os::raw::c_char,
                       __service: *const ::std::os::raw::c_char,
                       __req: *const Struct_addrinfo,
                       __pai: *mut *mut Struct_addrinfo)
     -> ::std::os::raw::c_int;
    pub fn freeaddrinfo(__ai: *mut Struct_addrinfo);
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn getnameinfo(__sa: *const Struct_sockaddr, __salen: socklen_t,
                       __host: *mut ::std::os::raw::c_char,
                       __hostlen: socklen_t,
                       __serv: *mut ::std::os::raw::c_char,
                       __servlen: socklen_t, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setpwent();
    pub fn endpwent();
    pub fn getpwent() -> *mut Struct_passwd;
    pub fn fgetpwent(__stream: *mut FILE) -> *mut Struct_passwd;
    pub fn putpwent(__p: *const Struct_passwd, __f: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn getpwuid(__uid: __uid_t) -> *mut Struct_passwd;
    pub fn getpwnam(__name: *const ::std::os::raw::c_char)
     -> *mut Struct_passwd;
    pub fn getpwent_r(__resultbuf: *mut Struct_passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn getpwuid_r(__uid: __uid_t, __resultbuf: *mut Struct_passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn getpwnam_r(__name: *const ::std::os::raw::c_char,
                      __resultbuf: *mut Struct_passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: size_t,
                      __result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn fgetpwent_r(__stream: *mut FILE, __resultbuf: *mut Struct_passwd,
                       __buffer: *mut ::std::os::raw::c_char,
                       __buflen: size_t, __result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn pg_set_noblock(sock: pgsocket) -> _bool;
    pub fn pg_set_block(sock: pgsocket) -> _bool;
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> _bool;
    pub fn first_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn last_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn first_path_var_separator(pathlist: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn join_path_components(ret_path: *mut ::std::os::raw::c_char,
                                head: *const ::std::os::raw::c_char,
                                tail: *const ::std::os::raw::c_char);
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn path_is_prefix_of_path(path1: *const ::std::os::raw::c_char,
                                  path2: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn get_progname(argv0: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn get_share_path(my_exec_path: *const ::std::os::raw::c_char,
                          ret_path: *mut ::std::os::raw::c_char);
    pub fn get_etc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_include_path(my_exec_path: *const ::std::os::raw::c_char,
                            ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkginclude_path(my_exec_path: *const ::std::os::raw::c_char,
                               ret_path: *mut ::std::os::raw::c_char);
    pub fn get_includeserver_path(my_exec_path: *const ::std::os::raw::c_char,
                                  ret_path: *mut ::std::os::raw::c_char);
    pub fn get_lib_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkglib_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_locale_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_doc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_html_path(my_exec_path: *const ::std::os::raw::c_char,
                         ret_path: *mut ::std::os::raw::c_char);
    pub fn get_man_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> _bool;
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
    pub fn pgfnames(path: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
    pub fn set_pglocale_pgservice(argv0: *const ::std::os::raw::c_char,
                                  app: *const ::std::os::raw::c_char);
    pub fn find_my_exec(argv0: *const ::std::os::raw::c_char,
                        retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn find_other_exec(argv0: *const ::std::os::raw::c_char,
                           target: *const ::std::os::raw::c_char,
                           versionstr: *const ::std::os::raw::c_char,
                           retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
    pub fn pg_strcasecmp(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_strncasecmp(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: size_t)
     -> ::std::os::raw::c_int;
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn simple_prompt(prompt: *const ::std::os::raw::c_char,
                         maxlen: ::std::os::raw::c_int, echo: _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: _bool)
     -> _bool;
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
    pub fn fls(mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getpeereid(sock: ::std::os::raw::c_int, uid: *mut uid_t,
                      gid: *mut gid_t) -> ::std::os::raw::c_int;
    pub fn strlcat(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: size_t) -> size_t;
    pub fn strlcpy(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: size_t) -> size_t;
    pub fn pqStrerror(errnum: ::std::os::raw::c_int,
                      strerrbuf: *mut ::std::os::raw::c_char, buflen: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut Struct_passwd,
                      buffer: *mut ::std::os::raw::c_char, buflen: size_t,
                      result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn pqGethostbyname(name: *const ::std::os::raw::c_char,
                           resultbuf: *mut Struct_hostent,
                           buffer: *mut ::std::os::raw::c_char,
                           buflen: size_t, result: *mut *mut Struct_hostent,
                           herrno: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pg_qsort(base: *mut ::std::os::raw::c_void, nel: size_t,
                    elsize: size_t,
                    cmp:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
    pub fn pg_qsort_strcmp(a: *const ::std::os::raw::c_void,
                           b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn qsort_arg(base: *mut ::std::os::raw::c_void, nel: size_t,
                     elsize: size_t, cmp: qsort_arg_comparator,
                     arg: *mut ::std::os::raw::c_void);
    pub fn pg_get_encoding_from_locale(ctype: *const ::std::os::raw::c_char,
                                       write_message: _bool)
     -> ::std::os::raw::c_int;
    pub fn inet_net_ntop(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_void,
                         bits: ::std::os::raw::c_int,
                         dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_mkdir_p(path: *mut ::std::os::raw::c_char,
                      omode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn setjmp(__env: jmp_buf) -> ::std::os::raw::c_int;
    pub fn __sigsetjmp(__env: *mut Struct___jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _setjmp(__env: *mut Struct___jmp_buf_tag) -> ::std::os::raw::c_int;
    pub fn longjmp(__env: *mut Struct___jmp_buf_tag,
                   __val: ::std::os::raw::c_int);
    pub fn _longjmp(__env: *mut Struct___jmp_buf_tag,
                    __val: ::std::os::raw::c_int);
    pub fn siglongjmp(__env: sigjmp_buf, __val: ::std::os::raw::c_int);
    pub fn errstart(elevel: ::std::os::raw::c_int,
                    filename: *const ::std::os::raw::c_char,
                    lineno: ::std::os::raw::c_int,
                    funcname: *const ::std::os::raw::c_char,
                    domain: *const ::std::os::raw::c_char) -> _bool;
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_plural(fmt_singular: *const ::std::os::raw::c_char,
                         fmt_plural: *const ::std::os::raw::c_char,
                         n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_log_plural(fmt_singular: *const ::std::os::raw::c_char,
                                fmt_plural: *const ::std::os::raw::c_char,
                                n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_plural(fmt_singular: *const ::std::os::raw::c_char,
                            fmt_plural: *const ::std::os::raw::c_char,
                            n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errhidestmt(hide_stmt: _bool) -> ::std::os::raw::c_int;
    pub fn errfunction(funcname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrquery(query: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn err_generic_string(field: ::std::os::raw::c_int,
                              str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn geterrcode() -> ::std::os::raw::c_int;
    pub fn geterrposition() -> ::std::os::raw::c_int;
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
    pub fn elog_start(filename: *const ::std::os::raw::c_char,
                      lineno: ::std::os::raw::c_int,
                      funcname: *const ::std::os::raw::c_char);
    pub fn elog_finish(elevel: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
    pub fn pre_format_elog_string(errnumber: ::std::os::raw::c_int,
                                  domain: *const ::std::os::raw::c_char);
    pub fn format_elog_string(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn EmitErrorReport();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData);
    pub fn FlushErrorState();
    pub fn ReThrowError(edata: *mut ErrorData);
    pub fn pg_re_throw();
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
    pub fn DebugFileOpen();
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn in_error_recursion_trouble() -> _bool;
    pub fn set_syslog_parameters(ident: *const ::std::os::raw::c_char,
                                 facility: ::std::os::raw::c_int);
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn repalloc(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn repalloc_huge(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pstrdup(_in: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pnstrdup(_in: *const ::std::os::raw::c_char, len: Size)
     -> *mut ::std::os::raw::c_char;
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn pvsnprintf(buf: *mut ::std::os::raw::c_char, len: size_t,
                      fmt: *const ::std::os::raw::c_char, args: va_list)
     -> size_t;
    pub fn DatumGetFloat4(X: Datum) -> float4;
    pub fn Float4GetDatum(X: float4) -> Datum;
    pub fn DatumGetFloat8(X: Datum) -> float8;
    pub fn Float8GetDatum(X: float8) -> Datum;
    pub fn ExceptionalCondition(conditionName: *const ::std::os::raw::c_char,
                                errorType: *const ::std::os::raw::c_char,
                                fileName: *const ::std::os::raw::c_char,
                                lineNumber: ::std::os::raw::c_int);
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext);
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext);
    pub fn pg_detoast_datum(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_copy(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_slice(datum: *mut Struct_varlena, first: int32,
                                  count: int32) -> *mut Struct_varlena;
    pub fn pg_detoast_datum_packed(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo,
                             str: *mut ::std::os::raw::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidInputFunctionCall(functionId: Oid,
                                str: *mut ::std::os::raw::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(filehandle: *mut ::std::os::raw::c_void,
                              funcname: *mut ::std::os::raw::c_char)
     -> *const Pg_finfo_record;
    pub fn clear_external_function_hash(filehandle:
                                            *mut ::std::os::raw::c_void);
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char)
     -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo,
                               argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr,
                                 argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::std::os::raw::c_int) -> _bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr,
                                    argnum: ::std::os::raw::c_int) -> _bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> _bool;
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> _bool;
    pub fn load_external_function(filename: *mut ::std::os::raw::c_char,
                                  funcname: *mut ::std::os::raw::c_char,
                                  signalNotFound: _bool,
                                  filehandle:
                                      *mut *mut ::std::os::raw::c_void)
     -> PGFunction;
    pub fn lookup_external_function(filehandle: *mut ::std::os::raw::c_void,
                                    funcname: *mut ::std::os::raw::c_char)
     -> PGFunction;
    pub fn load_file(filename: *const ::std::os::raw::c_char,
                     restricted: _bool);
    pub fn find_rendezvous_variable(varName: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_void;
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::std::os::raw::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum);
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::std::os::raw::c_char;
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset);
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset)
     -> _bool;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> _bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_is_empty(a: *const Bitmapset) -> _bool;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn nodeToString(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
    pub fn stringToNode(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn copyObject(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn equal(a: *const ::std::os::raw::c_void,
                 b: *const ::std::os::raw::c_void) -> _bool;
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::std::os::raw::c_void) -> *mut ListCell;
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::std::os::raw::c_int) -> *mut ListCell;
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List)
     -> *mut List;
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List)
     -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
    pub fn list_member(list: *const List,
                       datum: *const ::std::os::raw::c_void) -> _bool;
    pub fn list_member_ptr(list: *const List,
                           datum: *const ::std::os::raw::c_void) -> _bool;
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int)
     -> _bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> _bool;
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_delete_ptr(list: *mut List,
                           datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_append_unique(list: *mut List,
                              datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List,
                                  datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_int(list: *mut List,
                                  datum: ::std::os::raw::c_int) -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_free(list: *mut List);
    pub fn list_free_deep(list: *mut List);
    pub fn list_copy(list: *const List) -> *mut List;
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int)
     -> *mut List;
    pub fn makeInteger(i: ::std::os::raw::c_long) -> *mut Value;
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::std::os::raw::c_char,
                      result: *mut _bool) -> _bool;
    pub fn parse_bool_with_len(value: *const ::std::os::raw::c_char,
                               len: size_t, result: *mut _bool) -> _bool;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_check(value: Datum, isnull: _bool, domainType: Oid,
                        extra: *mut *mut ::std::os::raw::c_void,
                        mcxt: MemoryContext);
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hex_encode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn hex_decode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int)
     -> *mut int2vector;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_atoi(s: *mut ::std::os::raw::c_char,
                   size: ::std::os::raw::c_int, c: ::std::os::raw::c_int)
     -> int32;
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_float8_infinity() -> ::std::os::raw::c_double;
    pub fn get_float4_infinity() -> ::std::os::raw::c_float;
    pub fn get_float8_nan() -> ::std::os::raw::c_double;
    pub fn get_float4_nan() -> ::std::os::raw::c_float;
    pub fn is_infinite(val: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn read_binary_file(filename: *const ::std::os::raw::c_char,
                            seek_offset: int64, bytes_to_read: int64)
     -> *mut bytea;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int)
     -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: _bool,
                               collation: Oid, exact: *mut _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn stringToQualifiedNameList(string: *const ::std::os::raw::c_char)
     -> *mut List;
    pub fn format_procedure(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_procedure_qualified(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_operator(operator_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_operator_qualified(operator_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_string(indexrelid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_indexdef_columns(indexrelid: Oid, pretty: _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_string(constraintId: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn deparse_expression(expr: *mut Node, dpcontext: *mut List,
                              forceprefix: _bool, showimplicit: _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn deparse_context_for(aliasname: *const ::std::os::raw::c_char,
                               relid: Oid) -> *mut List;
    pub fn deparse_context_for_plan_rtable(rtable: *mut List,
                                           rtable_names: *mut List)
     -> *mut List;
    pub fn set_deparse_context_planstate(dpcontext: *mut List,
                                         planstate: *mut Node,
                                         ancestors: *mut List) -> *mut List;
    pub fn select_rtable_names_for_explain(rtable: *mut List,
                                           rels_used: *mut Bitmapset)
     -> *mut List;
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn quote_qualified_identifier(qualifier:
                                          *const ::std::os::raw::c_char,
                                      ident: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn generate_collation_name(collid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(s: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
    pub fn text_to_cstring_buffer(src: *const text,
                                  dst: *mut ::std::os::raw::c_char,
                                  dst_len: size_t);
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varstr_cmp(arg1: *mut ::std::os::raw::c_char,
                      len1: ::std::os::raw::c_int,
                      arg2: *mut ::std::os::raw::c_char,
                      len2: ::std::os::raw::c_int, collid: Oid)
     -> ::std::os::raw::c_int;
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
    pub fn SplitIdentifierString(rawstring: *mut ::std::os::raw::c_char,
                                 separator: ::std::os::raw::c_char,
                                 namelist: *mut *mut List) -> _bool;
    pub fn SplitDirectoriesString(rawstring: *mut ::std::os::raw::c_char,
                                  separator: ::std::os::raw::c_char,
                                  namelist: *mut *mut List) -> _bool;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text_regexp(src_text: *mut text,
                               regexp: *mut ::std::os::raw::c_void,
                               replace_text: *mut text, glob: _bool)
     -> *mut text;
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidComparator(arg1: *const ::std::os::raw::c_void,
                         arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_cidr_ntop(af: ::std::os::raw::c_int,
                          src: *const ::std::os::raw::c_void,
                          bits: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn inet_net_pton(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_char,
                         dst: *mut ::std::os::raw::c_void, size: size_t)
     -> ::std::os::raw::c_int;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid)
     -> ::std::os::raw::c_double;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_scan_first(_in: Datum) -> Datum;
    pub fn network_scan_last(_in: Datum) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int,
                           addr: *mut ::std::os::raw::c_char);
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_character_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_type_be_qualified(type_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str: StringInfo);
    pub fn resetStringInfo(str: StringInfo);
    pub fn appendStringInfo(str: StringInfo,
                            fmt: *const ::std::os::raw::c_char, ...);
    pub fn appendStringInfoVA(str: StringInfo,
                              fmt: *const ::std::os::raw::c_char,
                              args: va_list) -> ::std::os::raw::c_int;
    pub fn appendStringInfoString(str: StringInfo,
                                  s: *const ::std::os::raw::c_char);
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
    pub fn appendStringInfoSpaces(str: StringInfo,
                                  count: ::std::os::raw::c_int);
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::std::os::raw::c_char,
                                  datalen: ::std::os::raw::c_int);
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn escape_json(buf: StringInfo, str: *const ::std::os::raw::c_char);
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> _bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut _bool);
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> _bool;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::std::os::raw::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: _bool,
                                      strategy: *mut ::std::os::raw::c_int,
                                      lefttype: *mut Oid,
                                      righttype: *mut Oid);
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> _bool;
    pub fn get_sort_function_for_ordering_op(opno: Oid, sortfunc: *mut Oid,
                                             issupport: *mut _bool,
                                             reverse: *mut _bool) -> _bool;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut _bool)
     -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: _bool)
     -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> _bool;
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> _bool;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> _bool;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
    pub fn get_attname(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char)
     -> AttrNumber;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid);
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_strict(opno: Oid) -> _bool;
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::std::os::raw::c_int) -> Oid;
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> _bool;
    pub fn func_strict(funcid: Oid) -> _bool;
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> _bool;
    pub fn get_func_cost(funcid: Oid) -> float4;
    pub fn get_func_rows(funcid: Oid) -> float4;
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char,
                             relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_typisdefined(typid: Oid) -> _bool;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> _bool;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut _bool);
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut _bool,
                                typalign: *mut ::std::os::raw::c_char);
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut _bool,
                            typalign: *mut ::std::os::raw::c_char,
                            typdelim: *mut ::std::os::raw::c_char,
                            typioparam: *mut Oid, func: *mut Oid);
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
    pub fn type_is_rowtype(typid: Oid) -> _bool;
    pub fn type_is_enum(typid: Oid) -> _bool;
    pub fn type_is_range(typid: Oid) -> _bool;
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory:
                                           *mut ::std::os::raw::c_char,
                                       typispreferred: *mut _bool);
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(_type: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid);
    pub fn getTypeOutputInfo(_type: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut _bool);
    pub fn getTypeBinaryInputInfo(_type: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid);
    pub fn getTypeBinaryOutputInfo(_type: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut _bool);
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> _bool;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(statstuple: HeapTuple, atttype: Oid,
                            atttypmod: int32, reqkind: ::std::os::raw::c_int,
                            reqop: Oid, actualop: *mut Oid,
                            values: *mut *mut Datum,
                            nvalues: *mut ::std::os::raw::c_int,
                            numbers: *mut *mut float4,
                            nnumbers: *mut ::std::os::raw::c_int) -> _bool;
    pub fn free_attstatsslot(atttype: Oid, values: *mut Datum,
                             nvalues: ::std::os::raw::c_int,
                             numbers: *mut float4,
                             nnumbers: ::std::os::raw::c_int);
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int,
                                   hasoid: _bool) -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::std::os::raw::c_int, hasoid: _bool,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber);
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> _bool;
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::std::os::raw::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::std::os::raw::c_int);
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid);
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
    pub fn fcntl(__fd: ::std::os::raw::c_int,
                 __cmd: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn open(__file: *const ::std::os::raw::c_char,
                __oflag: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn openat(__fd: ::std::os::raw::c_int,
                  __file: *const ::std::os::raw::c_char,
                  __oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t)
     -> ::std::os::raw::c_int;
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: off_t) -> ::std::os::raw::c_int;
    pub fn posix_fadvise(__fd: ::std::os::raw::c_int, __offset: off_t,
                         __len: off_t, __advise: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn posix_fallocate(__fd: ::std::os::raw::c_int, __offset: off_t,
                           __len: off_t) -> ::std::os::raw::c_int;
    pub fn TransactionStartedDuringRecovery() -> _bool;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId)
     -> _bool;
    pub fn TransactionIdAbort(transactionId: TransactionId);
    pub fn TransactionIdCommitTree(xid: TransactionId,
                                   nxids: ::std::os::raw::c_int,
                                   xids: *mut TransactionId);
    pub fn TransactionIdAsyncCommitTree(xid: TransactionId,
                                        nxids: ::std::os::raw::c_int,
                                        xids: *mut TransactionId,
                                        lsn: XLogRecPtr);
    pub fn TransactionIdAbortTree(xid: TransactionId,
                                  nxids: ::std::os::raw::c_int,
                                  xids: *mut TransactionId);
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId,
                                         id2: TransactionId) -> _bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId,
                                        id2: TransactionId) -> _bool;
    pub fn TransactionIdLatest(mainxid: TransactionId,
                               nxids: ::std::os::raw::c_int,
                               xids: *const TransactionId) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn GetNewTransactionId(isSubXact: _bool) -> TransactionId;
    pub fn ReadNewTransactionId() -> TransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId,
                                 oldest_datoid: Oid);
    pub fn ForceTransactionIdLimitUpdate() -> _bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> _bool;
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: _bool,
                       is_heap: _bool) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
    pub fn PageRepairFragmentation(page: Page);
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::std::os::raw::c_int);
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
    pub fn heap_compute_data_size(tupleDesc: TupleDesc, values: *mut Datum,
                                  isnull: *mut _bool) -> Size;
    pub fn heap_fill_tuple(tupleDesc: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool,
                           data: *mut ::std::os::raw::c_char, data_size: Size,
                           infomask: *mut uint16, bit: *mut bits8);
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::std::os::raw::c_int)
     -> _bool;
    pub fn nocachegetattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                          att: TupleDesc) -> Datum;
    pub fn heap_getsysattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                           tupleDesc: TupleDesc, isnull: *mut _bool) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple);
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc)
     -> Datum;
    pub fn heap_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool) -> HeapTuple;
    pub fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             replValues: *mut Datum, replIsnull: *mut _bool,
                             doReplace: *mut _bool) -> HeapTuple;
    pub fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             values: *mut Datum, isnull: *mut _bool);
    pub fn heap_formtuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                          nulls: *mut ::std::os::raw::c_char) -> HeapTuple;
    pub fn heap_modifytuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            replValues: *mut Datum,
                            replNulls: *mut ::std::os::raw::c_char,
                            replActions: *mut ::std::os::raw::c_char)
     -> HeapTuple;
    pub fn heap_deformtuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            values: *mut Datum,
                            nulls: *mut ::std::os::raw::c_char);
    pub fn heap_freetuple(htup: HeapTuple);
    pub fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc,
                                   values: *mut Datum, isnull: *mut _bool)
     -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple);
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node);
    pub fn forkname_to_number(forkName: *const ::std::os::raw::c_char)
     -> ForkNumber;
    pub fn forkname_chars(str: *const ::std::os::raw::c_char,
                          fork: *mut ForkNumber) -> ::std::os::raw::c_int;
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::std::os::raw::c_int,
                           forkNumber: ForkNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage,
                                     n: ::std::os::raw::c_int);
    pub fn ReceiveSharedInvalidMessages(invalFunction:
                                            ::std::option::Option<unsafe extern "C" fn(msg:
                                                                                           *mut SharedInvalidationMessage)>,
                                        resetFunction:
                                            ::std::option::Option<extern "C" fn()>);
    pub fn HandleCatchupInterrupt();
    pub fn EnableCatchupInterrupt();
    pub fn DisableCatchupInterrupt() -> _bool;
    pub fn xactGetCommittedInvalidationMessages(msgs:
                                                    *mut *mut SharedInvalidationMessage,
                                                RelcacheInitFileInval:
                                                    *mut _bool)
     -> ::std::os::raw::c_int;
    pub fn ProcessCommittedInvalidationMessages(msgs:
                                                    *mut SharedInvalidationMessage,
                                                nmsgs: ::std::os::raw::c_int,
                                                RelcacheInitFileInval: _bool,
                                                dbid: Oid, tsid: Oid);
    pub fn LocalExecuteInvalidationMessage(msg:
                                               *mut SharedInvalidationMessage);
    pub fn hash_create(tabname: *const ::std::os::raw::c_char,
                       nelem: ::std::os::raw::c_long, info: *mut HASHCTL,
                       flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB);
    pub fn hash_stats(_where: *const ::std::os::raw::c_char,
                      hashp: *mut HTAB);
    pub fn hash_search(hashp: *mut HTAB,
                       keyPtr: *const ::std::os::raw::c_void,
                       action: HASHACTION, foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn get_hash_value(hashp: *mut HTAB,
                          keyPtr: *const ::std::os::raw::c_void) -> uint32;
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::std::os::raw::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::std::os::raw::c_void,
                                newKeyPtr: *const ::std::os::raw::c_void)
     -> _bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
    pub fn hash_freeze(hashp: *mut HTAB);
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long,
                              entrysize: Size) -> Size;
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL,
                                flags: ::std::os::raw::c_int) -> Size;
    pub fn AtEOXact_HashTables(isCommit: _bool);
    pub fn AtEOSubXact_HashTables(isCommit: _bool,
                                  nestDepth: ::std::os::raw::c_int);
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn oid_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_match(key1: *const ::std::os::raw::c_void,
                        key2: *const ::std::os::raw::c_void, keysize: Size)
     -> ::std::os::raw::c_int;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation);
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16);
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid);
    pub fn RelationInitIndexAccessInfo(relation: Relation);
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errtablecolname(rel: Relation,
                           colname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errtableconstraint(rel: Relation,
                              conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn RelationCacheInitialize();
    pub fn RelationCacheInitializePhase2();
    pub fn RelationCacheInitializePhase3();
    pub fn RelationBuildLocalRelation(relname: *const ::std::os::raw::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: _bool,
                                      mapped_relation: _bool,
                                      relpersistence: ::std::os::raw::c_char,
                                      relkind: ::std::os::raw::c_char)
     -> Relation;
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId);
    pub fn RelationForgetRelation(rid: Oid);
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
    pub fn RelationCacheInvalidate();
    pub fn RelationCloseSmgrByOid(relationId: Oid);
    pub fn AtEOXact_RelationCache(isCommit: _bool);
    pub fn AtEOSubXact_RelationCache(isCommit: _bool,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId);
    pub fn RelationIdIsInInitFile(relationId: Oid) -> _bool;
    pub fn RelationCacheInitFilePreInvalidate();
    pub fn RelationCacheInitFilePostInvalidate();
    pub fn RelationCacheInitFileRemove();
    pub fn RelationIncrementReferenceCount(rel: Relation);
    pub fn RelationDecrementReferenceCount(rel: Relation);
    pub fn acos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2(__y: ::std::os::raw::c_double, __x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __atan2(__y: ::std::os::raw::c_double,
                   __x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn frexp(__x: ::std::os::raw::c_double,
                 __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __frexp(__x: ::std::os::raw::c_double,
                   __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ldexp(__x: ::std::os::raw::c_double,
                 __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __ldexp(__x: ::std::os::raw::c_double,
                   __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn log(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn modf(__x: ::std::os::raw::c_double,
                __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __modf(__x: ::std::os::raw::c_double,
                  __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn expm1(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expm1(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log1p(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log1p(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn pow(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __pow(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn sqrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sqrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypot(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __hypot(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cbrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cbrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ceil(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __ceil(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fabs(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fabs(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floor(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __floor(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmod(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmod(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __isinf(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __finite(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isinf(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn finite(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn drem(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __drem(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn significand(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __significand(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn copysign(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __copysign(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nan(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __nan(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __isnan(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isnan(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn j0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn j1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn y0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn y1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn erf(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erf(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __lgamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn tgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tgamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn gamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __gamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgamma_r(arg1: ::std::os::raw::c_double,
                    __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __lgamma_r(arg1: ::std::os::raw::c_double,
                      __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __rint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn nextafter(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nextafter(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttoward(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nexttoward(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remainder(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __remainder(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn scalbn(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __scalbn(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ilogb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn __ilogb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn scalbln(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_double;
    pub fn __scalbln(__x: ::std::os::raw::c_double,
                     __n: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn nearbyint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nearbyint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn round(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __round(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn trunc(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __trunc(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn remquo(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double,
                  __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __remquo(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double,
                    __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn lrint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lrint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llrint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llrint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn lround(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lround(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llround(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llround(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn fdim(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fdim(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmax(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmax(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmin(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmin(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fpclassify(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __signbit(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn fma(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
               __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fma(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
                 __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn scalb(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __scalb(__x: ::std::os::raw::c_double,
                   __n: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __acosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __asinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __atanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atan2f(__y: ::std::os::raw::c_float, __x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __atan2f(__y: ::std::os::raw::c_float,
                    __x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __cosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn coshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __coshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn acoshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __acoshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __asinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __atanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn expf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __expf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn frexpf(__x: ::std::os::raw::c_float,
                  __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __frexpf(__x: ::std::os::raw::c_float,
                    __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn ldexpf(__x: ::std::os::raw::c_float,
                  __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __ldexpf(__x: ::std::os::raw::c_float,
                    __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn logf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __logf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn modff(__x: ::std::os::raw::c_float,
                 __iptr: *mut ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __modff(__x: ::std::os::raw::c_float,
                   __iptr: *mut ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn expm1f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __expm1f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log1pf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log1pf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn logbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __logbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn exp2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __exp2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn powf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __powf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn sqrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sqrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn hypotf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __hypotf(__x: ::std::os::raw::c_float,
                    __y: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cbrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __cbrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn ceilf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __ceilf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fabsf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __fabsf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn floorf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __floorf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fmodf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fmodf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __isinff(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __finitef(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn isinff(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn finitef(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn dremf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __dremf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn significandf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __significandf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn copysignf(__x: ::std::os::raw::c_float,
                     __y: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __copysignf(__x: ::std::os::raw::c_float,
                       __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nanf(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn __isnanf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn isnanf(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn j0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __j0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn j1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __j1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn y0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __y0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn y1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __y1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn erff(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __erff(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn erfcf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __erfcf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn lgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __lgammaf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn tgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tgammaf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn gammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __gammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn lgammaf_r(arg1: ::std::os::raw::c_float,
                     __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __lgammaf_r(arg1: ::std::os::raw::c_float,
                       __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn rintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __rintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn nextafterf(__x: ::std::os::raw::c_float,
                      __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __nextafterf(__x: ::std::os::raw::c_float,
                        __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nexttowardf(__x: ::std::os::raw::c_float,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_float;
    pub fn __nexttowardf(__x: ::std::os::raw::c_float,
                         __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_float;
    pub fn remainderf(__x: ::std::os::raw::c_float,
                      __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __remainderf(__x: ::std::os::raw::c_float,
                        __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn scalbnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __scalbnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn ilogbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn __ilogbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn scalblnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_float;
    pub fn __scalblnf(__x: ::std::os::raw::c_float,
                      __n: ::std::os::raw::c_long) -> ::std::os::raw::c_float;
    pub fn nearbyintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __nearbyintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn roundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __roundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn truncf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __truncf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn remquof(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                   __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __remquof(__x: ::std::os::raw::c_float,
                     __y: ::std::os::raw::c_float,
                     __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn lrintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn __lrintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn llrintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn __llrintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn lroundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn __lroundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn llroundf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn __llroundf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn fdimf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fdimf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fmaxf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fmaxf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fminf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fminf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fpclassifyf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __signbitf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn fmaf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                __z: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __fmaf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                  __z: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn scalbf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __scalbf(__x: ::std::os::raw::c_float,
                    __n: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn acosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2l(__y: ::std::os::raw::c_double,
                  __x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atan2l(__y: ::std::os::raw::c_double,
                    __x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn cosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn coshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __coshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acoshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acoshl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn asinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinhl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn atanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanhl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn expl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn frexpl(__x: ::std::os::raw::c_double,
                  __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __frexpl(__x: ::std::os::raw::c_double,
                    __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ldexpl(__x: ::std::os::raw::c_double,
                  __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __ldexpl(__x: ::std::os::raw::c_double,
                    __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn logl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log10l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn modfl(__x: ::std::os::raw::c_double,
                 __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __modfl(__x: ::std::os::raw::c_double,
                   __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn expm1l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expm1l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn log1pl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log1pl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn logbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn powl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __powl(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sqrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sqrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypotl(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __hypotl(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn cbrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cbrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ceill(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __ceill(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fabsl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fabsl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floorl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __floorl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn fmodl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmodl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __isinfl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __finitel(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isinfl(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn finitel(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn dreml(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __dreml(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn significandl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __significandl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn copysignl(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __copysignl(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nanl(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __isnanl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isnanl(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn j0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn j1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn y0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn y1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn erfl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfcl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfcl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __lgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn tgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __tgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn gammal(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __gammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgammal_r(arg1: ::std::os::raw::c_double,
                     __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __lgammal_r(arg1: ::std::os::raw::c_double,
                       __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __rintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn nextafterl(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nextafterl(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttowardl(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nexttowardl(__x: ::std::os::raw::c_double,
                         __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remainderl(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __remainderl(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn scalbnl(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __scalbnl(__x: ::std::os::raw::c_double,
                     __n: ::std::os::raw::c_int) -> ::std::os::raw::c_double;
    pub fn ilogbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn __ilogbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn scalblnl(__x: ::std::os::raw::c_double,
                    __n: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn __scalblnl(__x: ::std::os::raw::c_double,
                      __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_double;
    pub fn nearbyintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nearbyintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn roundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __roundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn truncl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __truncl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remquol(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double,
                   __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __remquol(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double,
                     __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn lrintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lrintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llrintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llrintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn lroundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lroundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llroundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llroundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn fdiml(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fdiml(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmaxl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmaxl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fminl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fminl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fpclassifyl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __signbitl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn fmal(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
                __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fmal(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double,
                  __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn scalbl(__x: ::std::os::raw::c_double,
                  __n: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __scalbl(__x: ::std::os::raw::c_double,
                    __n: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn matherr(__exc: *mut Struct_exception) -> ::std::os::raw::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz)
     -> *mut Struct_pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut Struct_pg_tm;
    pub fn pg_next_dst_boundary(timep: *const pg_time_t,
                                before_gmtoff: *mut ::std::os::raw::c_long,
                                before_isdst: *mut ::std::os::raw::c_int,
                                boundary: *mut pg_time_t,
                                after_gmtoff: *mut ::std::os::raw::c_long,
                                after_isdst: *mut ::std::os::raw::c_int,
                                tz: *const pg_tz) -> ::std::os::raw::c_int;
    pub fn pg_interpret_timezone_abbrev(abbrev: *const ::std::os::raw::c_char,
                                        timep: *const pg_time_t,
                                        gmtoff: *mut ::std::os::raw::c_long,
                                        isdst: *mut ::std::os::raw::c_int,
                                        tz: *const pg_tz) -> _bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz,
                                  gmtoff: *mut ::std::os::raw::c_long)
     -> _bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz)
     -> *const ::std::os::raw::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> _bool;
    pub fn pg_strftime(s: *mut ::std::os::raw::c_char, max: size_t,
                       format: *const ::std::os::raw::c_char,
                       tm: *const Struct_pg_tm) -> size_t;
    pub fn pg_timezone_initialize();
    pub fn pg_tzset(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn TimestampDifference(start_time: TimestampTz,
                               stop_time: TimestampTz,
                               secs: *mut ::std::os::raw::c_long,
                               microsecs: *mut ::std::os::raw::c_int);
    pub fn TimestampDifferenceExceeds(start_time: TimestampTz,
                                      stop_time: TimestampTz,
                                      msec: ::std::os::raw::c_int) -> _bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz)
     -> *const ::std::os::raw::c_char;
    pub fn tm2timestamp(tm: *mut Struct_pg_tm, fsec: fsec_t,
                        tzp: *mut ::std::os::raw::c_int, dt: *mut Timestamp)
     -> ::std::os::raw::c_int;
    pub fn timestamp2tm(dt: Timestamp, tzp: *mut ::std::os::raw::c_int,
                        tm: *mut Struct_pg_tm, fsec: *mut fsec_t,
                        tzn: *mut *const ::std::os::raw::c_char,
                        attimezone: *mut pg_tz) -> ::std::os::raw::c_int;
    pub fn dt2time(dt: Timestamp, hour: *mut ::std::os::raw::c_int,
                   min: *mut ::std::os::raw::c_int,
                   sec: *mut ::std::os::raw::c_int, fsec: *mut fsec_t);
    pub fn interval2tm(span: Interval, tm: *mut Struct_pg_tm,
                       fsec: *mut fsec_t) -> ::std::os::raw::c_int;
    pub fn tm2interval(tm: *mut Struct_pg_tm, fsec: fsec_t,
                       span: *mut Interval) -> ::std::os::raw::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut Struct_pg_tm);
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp)
     -> ::std::os::raw::c_int;
    pub fn isoweek2j(year: ::std::os::raw::c_int, week: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn isoweek2date(woy: ::std::os::raw::c_int,
                        year: *mut ::std::os::raw::c_int,
                        mon: *mut ::std::os::raw::c_int,
                        mday: *mut ::std::os::raw::c_int);
    pub fn isoweekdate2date(isoweek: ::std::os::raw::c_int,
                            wday: ::std::os::raw::c_int,
                            year: *mut ::std::os::raw::c_int,
                            mon: *mut ::std::os::raw::c_int,
                            mday: *mut ::std::os::raw::c_int);
    pub fn date2isoweek(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn date2isoyear(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn date2isoyearday(year: ::std::os::raw::c_int,
                           mon: ::std::os::raw::c_int,
                           mday: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(arg1: *mut ReorderBuffer);
    pub fn ReorderBufferGetTupleBuf(arg1: *mut ReorderBuffer, tuple_len: Size)
     -> *mut ReorderBufferTupleBuf;
    pub fn ReorderBufferReturnTupleBuf(arg1: *mut ReorderBuffer,
                                       tuple: *mut ReorderBufferTupleBuf);
    pub fn ReorderBufferGetChange(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(arg1: *mut ReorderBuffer,
                                     arg2: *mut ReorderBufferChange);
    pub fn ReorderBufferQueueChange(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    arg3: *mut ReorderBufferChange);
    pub fn ReorderBufferCommit(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr,
                               commit_time: TimestampTz);
    pub fn ReorderBufferAssignChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr);
    pub fn ReorderBufferCommitChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr,
                                    end_lsn: XLogRecPtr);
    pub fn ReorderBufferAbort(arg1: *mut ReorderBuffer, arg2: TransactionId,
                              lsn: XLogRecPtr);
    pub fn ReorderBufferAbortOld(arg1: *mut ReorderBuffer,
                                 xid: TransactionId);
    pub fn ReorderBufferForget(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               lsn: XLogRecPtr);
    pub fn ReorderBufferSetBaseSnapshot(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        snap: *mut Struct_SnapshotData);
    pub fn ReorderBufferAddSnapshot(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    snap: *mut Struct_SnapshotData);
    pub fn ReorderBufferAddNewCommandId(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        cid: CommandId);
    pub fn ReorderBufferAddNewTupleCids(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        node: RelFileNode,
                                        pt: ItemPointerData, cmin: CommandId,
                                        cmax: CommandId, combocid: CommandId);
    pub fn ReorderBufferAddInvalidations(arg1: *mut ReorderBuffer,
                                         arg2: TransactionId, lsn: XLogRecPtr,
                                         nmsgs: Size,
                                         msgs:
                                             *mut SharedInvalidationMessage);
    pub fn ReorderBufferProcessXid(arg1: *mut ReorderBuffer,
                                   xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferXidSetCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId,
                                             lsn: XLogRecPtr);
    pub fn ReorderBufferXidHasCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidHasBaseSnapshot(arg1: *mut ReorderBuffer,
                                           xid: TransactionId) -> _bool;
    pub fn ReorderBufferGetOldestTXN(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTXN;
    pub fn ReorderBufferSetRestartPoint(arg1: *mut ReorderBuffer,
                                        ptr: XLogRecPtr);
    pub fn StartupReorderBuffer();
    pub fn OutputPluginPrepareWrite(ctx: *mut Struct_LogicalDecodingContext,
                                    last_write: _bool);
    pub fn OutputPluginWrite(ctx: *mut Struct_LogicalDecodingContext,
                             last_write: _bool);
    pub fn XLogInsert(rmid: RmgrId, info: uint8, rdata: *mut XLogRecData)
     -> XLogRecPtr;
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> _bool;
    pub fn XLogFlush(RecPtr: XLogRecPtr);
    pub fn XLogBackgroundFlush() -> _bool;
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> _bool;
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut _bool,
                        use_lock: _bool) -> ::std::os::raw::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::std::os::raw::c_int;
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: _bool)
     -> XLogRecPtr;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr);
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
    pub fn RestoreBackupBlock(lsn: XLogRecPtr, record: *mut XLogRecord,
                              block_index: ::std::os::raw::c_int,
                              get_cleanup_lock: _bool, keep_buffer: _bool)
     -> Buffer;
    pub fn xlog_redo(lsn: XLogRecPtr, record: *mut XLogRecord);
    pub fn xlog_desc(buf: StringInfo, xl_info: uint8,
                     rec: *mut ::std::os::raw::c_char);
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo);
    pub fn RecoveryInProgress() -> _bool;
    pub fn HotStandbyActive() -> _bool;
    pub fn HotStandbyActiveInReplay() -> _bool;
    pub fn XLogInsertAllowed() -> _bool;
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz,
                              fromStream: *mut _bool);
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn RecoveryIsPaused() -> _bool;
    pub fn SetRecoveryPause(recoveryPause: _bool);
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::std::os::raw::c_char;
    pub fn UpdateControlFile();
    pub fn GetSystemIdentifier() -> uint64;
    pub fn DataChecksumsEnabled() -> _bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit();
    pub fn BootStrapXLOG();
    pub fn StartupXLOG();
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
    pub fn InitXLOGAccess();
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> _bool;
    pub fn XLogPutNextOid(nextOid: Oid);
    pub fn XLogRestorePoint(rpName: *const ::std::os::raw::c_char)
     -> XLogRecPtr;
    pub fn UpdateFullPageWrites();
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr() -> XLogRecPtr;
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32);
    pub fn RemovePromoteSignalFiles();
    pub fn CheckPromoteSignal() -> _bool;
    pub fn WakeupRecovery();
    pub fn SetWalWriterSleeping(sleeping: _bool);
    pub fn do_pg_start_backup(backupidstr: *const ::std::os::raw::c_char,
                              fast: _bool, starttli_p: *mut TimeLineID,
                              labelfile: *mut *mut ::std::os::raw::c_char)
     -> XLogRecPtr;
    pub fn do_pg_stop_backup(labelfile: *mut ::std::os::raw::c_char,
                             waitforarchive: _bool,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
    pub fn do_pg_abort_backup();
    pub fn GetLastSegSwitchTime() -> pg_time_t;
    pub fn RequestXLogSwitch() -> XLogRecPtr;
    pub fn GetOldestRestartPoint(oldrecptr: *mut XLogRecPtr,
                                 oldtli: *mut TimeLineID);
    pub fn RestoreArchivedFile(path: *mut ::std::os::raw::c_char,
                               xlogfname: *const ::std::os::raw::c_char,
                               recovername: *const ::std::os::raw::c_char,
                               expectedSize: off_t, cleanupEnabled: _bool)
     -> _bool;
    pub fn ExecuteRecoveryCommand(command: *mut ::std::os::raw::c_char,
                                  commandName: *mut ::std::os::raw::c_char,
                                  failOnerror: _bool);
    pub fn KeepFileRestoredFromArchive(path: *mut ::std::os::raw::c_char,
                                       xlogfname:
                                           *mut ::std::os::raw::c_char);
    pub fn XLogArchiveNotify(xlog: *const ::std::os::raw::c_char);
    pub fn XLogArchiveNotifySeg(segno: XLogSegNo);
    pub fn XLogArchiveForceDone(xlog: *const ::std::os::raw::c_char);
    pub fn XLogArchiveCheckDone(xlog: *const ::std::os::raw::c_char) -> _bool;
    pub fn XLogArchiveIsBusy(xlog: *const ::std::os::raw::c_char) -> _bool;
    pub fn XLogArchiveIsReady(xlog: *const ::std::os::raw::c_char) -> _bool;
    pub fn XLogArchiveCleanup(xlog: *const ::std::os::raw::c_char);
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::std::os::raw::c_void)
     -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState);
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::std::os::raw::c_char)
     -> *mut Struct_XLogRecord;
    pub fn s_lock(lock: *mut slock_t, file: *const ::std::os::raw::c_char,
                  line: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
    pub fn update_spins_per_delay(shared_spins_per_delay:
                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> _bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockRelease(lock: *mut LWLock);
    pub fn LWLockReleaseAll();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> _bool;
    pub fn LWLockAcquireWithVar(lock: *mut LWLock, valptr: *mut uint64,
                                val: uint64) -> _bool;
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> _bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64);
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks();
    pub fn RequestAddinLWLocks(n: ::std::os::raw::c_int);
    pub fn LWLockAssign() -> *mut LWLock;
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
    pub fn LWLockRegisterTranche(arg1: ::std::os::raw::c_int,
                                 arg2: *mut LWLockTranche);
    pub fn LWLockInitialize(arg1: *mut LWLock,
                            tranche_id: ::std::os::raw::c_int);
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
    pub fn InitShmemAllocation();
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> _bool;
    pub fn InitShmemIndex();
    pub fn ShmemInitHash(name: *const ::std::os::raw::c_char,
                         init_size: ::std::os::raw::c_long,
                         max_size: ::std::os::raw::c_long,
                         infoP: *mut HASHCTL,
                         hash_flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn ShmemInitStruct(name: *const ::std::os::raw::c_char, size: Size,
                           foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size);
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE);
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> _bool;
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> _bool;
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit();
    pub fn ReplicationSlotCreate(name: *const ::std::os::raw::c_char,
                                 db_specific: _bool,
                                 p: ReplicationSlotPersistency);
    pub fn ReplicationSlotPersist();
    pub fn ReplicationSlotDrop(name: *const ::std::os::raw::c_char);
    pub fn ReplicationSlotAcquire(name: *const ::std::os::raw::c_char);
    pub fn ReplicationSlotRelease();
    pub fn ReplicationSlotSave();
    pub fn ReplicationSlotMarkDirty();
    pub fn ReplicationSlotValidateName(name: *const ::std::os::raw::c_char,
                                       elevel: ::std::os::raw::c_int)
     -> _bool;
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: _bool);
    pub fn ReplicationSlotsComputeRequiredLSN();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(dboid: Oid,
                                        nslots: *mut ::std::os::raw::c_int,
                                        nactive: *mut ::std::os::raw::c_int)
     -> _bool;
    pub fn StartupReplicationSlots();
    pub fn CheckPointReplicationSlots();
    pub fn CheckSlotRequirements();
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn CheckLogicalDecodingRequirements();
    pub fn CreateInitDecodingContext(plugin: *mut ::std::os::raw::c_char,
                                     output_plugin_options: *mut List,
                                     read_page: XLogPageReadCB,
                                     prepare_write:
                                         LogicalOutputPluginWriterPrepareWrite,
                                     do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(start_lsn: XLogRecPtr,
                                 output_plugin_options: *mut List,
                                 read_page: XLogPageReadCB,
                                 prepare_write:
                                     LogicalOutputPluginWriterPrepareWrite,
                                 do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext);
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> _bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext);
    pub fn LogicalIncreaseXminForSlot(lsn: XLogRecPtr, xmin: TransactionId);
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr,
                                                 restart_lsn: XLogRecPtr);
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr);
}
